// Generated by dts-bundle-generator v6.8.0

declare const dateFormatFunctions: {
	readonly "dd MMM 'yy": (date: Date, local: boolean) => string;
	readonly "MMM dd, yyyy": (date: Date, local: boolean) => string;
	readonly "MMM dd": (date: Date, local: boolean) => string;
	readonly "yyyy-MM-dd": (date: Date, local: boolean) => string;
	readonly "yy-MM-dd": (date: Date, local: boolean) => string;
	readonly "yy/MM/dd": (date: Date, local: boolean) => string;
	readonly "yyyy/MM/dd": (date: Date, local: boolean) => string;
	readonly "dd-MM-yyyy": (date: Date, local: boolean) => string;
	readonly "dd-MM-yy": (date: Date, local: boolean) => string;
	readonly "dd/MM/yy": (date: Date, local: boolean) => string;
	readonly "dd/MM/yyyy": (date: Date, local: boolean) => string;
	readonly "MM/dd/yy": (date: Date, local: boolean) => string;
	readonly "MM/dd/yyyy": (date: Date, local: boolean) => string;
};
declare enum HHistDirection {
	LeftToRight = "left_to_right",
	RightToLeft = "right_to_left"
}
declare enum LineStudyPlotStyle {
	Line = 0,
	Histogram = 1,
	Cross = 3,
	Area = 4,
	Columns = 5,
	Circles = 6,
	LineWithBreaks = 7,
	AreaWithBreaks = 8,
	StepLine = 9,
	StepLineWithDiamonds = 10
}
declare enum LineStyle {
	Solid = 0,
	Dotted = 1,
	Dashed = 2
}
declare enum MarkLocation {
	AboveBar = "AboveBar",
	BelowBar = "BelowBar",
	Top = "Top",
	Bottom = "Bottom",
	Right = "Right",
	Left = "Left",
	Absolute = "Absolute",
	AbsoluteUp = "AbsoluteUp",
	AbsoluteDown = "AbsoluteDown"
}
declare enum OrderOrPositionMessageType {
	Information = "information",
	Warning = "warning",
	Error = "error"
}
declare enum PlotSymbolSize {
	Auto = "auto",
	Tiny = "tiny",
	Small = "small",
	Normal = "normal",
	Large = "large",
	Huge = "huge"
}
declare enum StopType {
	StopLoss = 0,
	TrailingStop = 1
}
export declare const enum ActionId {
	ChartAddIndicatorToAllCharts = "Chart.AddIndicatorToAllCharts",
	ChartAddSymbolToWatchList = "Chart.AddSymbolToWatchList",
	ChartApplyIndicatorsToAllCharts = "Chart.ApplyIndicatorsToAllCharts",
	ChartChangeTimeZone = "Chart.ChangeTimeZone",
	ChartClipboardCopyPrice = "Chart.Clipboard.CopyPrice",
	ChartClipboardCopyLineTools = "Chart.Clipboard.CopyLineTools",
	ChartClipboardCopySource = "Chart.Clipboard.CopySource",
	ChartClipboardPasteSource = "Chart.Clipboard.PasteSource",
	ChartCrosshairLockVerticalCursor = "Chart.Crosshair.LockVerticalCursor",
	ChartCrosshairPlusButtonDrawHorizontalLine = "Chart.Crosshair.PlusButton.DrawHorizontalLine",
	ChartCustomActionId = "Chart.CustomActionId",
	ChartDialogsShowChangeInterval = "Chart.Dialogs.ShowChangeInterval",
	ChartDialogsShowChangeSymbol = "Chart.Dialogs.ShowChangeSymbol",
	ChartDialogsShowCompareOrAddSymbol = "Chart.Dialogs.ShowCompareOrAddSymbol",
	ChartDialogsShowGeneralSettings = "Chart.Dialogs.ShowGeneralSettings",
	ChartDialogsShowGeneralSettingsLegendTab = "Chart.Dialogs.ShowGeneralSettings.LegendTab",
	ChartDialogsShowGeneralSettingsScalesTab = "Chart.Dialogs.ShowGeneralSettings.ScalesTab",
	ChartDialogsShowGeneralSettingsSymbolTab = "Chart.Dialogs.ShowGeneralSettings.SymbolTab",
	ChartDialogsShowGoToDate = "Chart.Dialogs.ShowGoToDate",
	ChartDialogsShowInsertIndicators = "Chart.Dialogs.ShowInsertIndicators",
	ChartDialogsShowSymbolInfo = "Chart.Dialogs.ShowSymbolInfo",
	ChartDrawingToolbarToggleVisibility = "Chart.DrawingToolbar.ToggleVisibility",
	ChartExternalActionId = "Chart.ExternalActionId",
	ChartFavoriteDrawingToolsToolbarHide = "Chart.FavoriteDrawingToolsToolbar.Hide",
	ChartIndicatorShowSettingsDialog = "Chart.Indicator.ShowSettingsDialog",
	ChartLegendToggleBarChangeValuesVisibility = "Chart.Legend.ToggleBarChangeValuesVisibility",
	ChartLegendToggleIndicatorArgumentsVisibility = "Chart.Legend.ToggleIndicatorArgumentsVisibility",
	ChartLegendToggleIndicatorTitlesVisibility = "Chart.Legend.ToggleIndicatorTitlesVisibility",
	ChartLegendToggleIndicatorValuesVisibility = "Chart.Legend.ToggleIndicatorValuesVisibility",
	ChartLegendToggleOhlcValuesVisibility = "Chart.Legend.ToggleOhlcValuesVisibility",
	ChartLegendToggleOpenMarketStatusVisibility = "Chart.Legend.ToggleOpenMarketStatusVisibility",
	ChartLegendToggleSymbolVisibility = "Chart.Legend.ToggleSymbolVisibility",
	ChartLegendToggleVolumeVisibility = "Chart.Legend.ToggleVolumeVisibility",
	ChartLines = "Chart.Lines",
	ChartLinesToggleBidAskLinesVisibility = "Chart.Lines.ToggleBidAskLinesVisibility",
	ChartLinesToggleHighLowLinesVisibility = "Chart.Lines.ToggleHighLowLinesVisibility",
	ChartLinesToggleAverageLineVisibility = "Chart.Lines.ToggleAverageLineVisibility",
	ChartLinesToggleSeriesPrevCloseLineVisibility = "Chart.Lines.ToggleSeriesPrevCloseLineVisibility",
	ChartLinesToggleSeriesPriceLineVisibility = "Chart.Lines.ToggleSeriesPriceLineVisibility",
	ChartLineToolBarsPatternToggleFlipped = "Chart.LineTool.BarsPattern.ToggleFlipped",
	ChartLineToolBarsPatternToggleMirrored = "Chart.LineTool.BarsPattern.ToggleMirrored",
	ChartLineToolClone = "Chart.LineTool.Clone",
	ChartLineToolCreateLimitOrderFromState = "Chart.LineTool.CreateLimitOrderFromState",
	ChartLineToolElliotChangeDegreeProperty = "Chart.LineTool.Elliot.ChangeDegreeProperty",
	ChartLineToolNoSync = "Chart.LineTool.NoSync",
	ChartLineToolPitchforkChangeTypeToInside = "Chart.LineTool.Pitchfork.ChangeTypeToInside",
	ChartLineToolPitchforkChangeTypeToModifiedSchiff = "Chart.LineTool.Pitchfork.ChangeTypeToModifiedSchiff",
	ChartLineToolPitchforkChangeTypeToOriginal = "Chart.LineTool.Pitchfork.ChangeTypeToOriginal",
	ChartLineToolPitchforkChangeTypeToSchiff = "Chart.LineTool.Pitchfork.ChangeTypeToSchiff",
	ChartLineToolSyncInLayout = "Chart.LineTool.SyncInLayout",
	ChartLineToolTemplates = "Chart.LineTool.Templates",
	ChartLineToolTemplatesApply = "Chart.LineTool.Templates.Apply",
	ChartLineToolTemplatesApplyDefaults = "Chart.LineTool.Templates.ApplyDefaults",
	ChartLineToolTemplatesSaveAs = "Chart.LineTool.Templates.SaveAs",
	ChartLineToolToolbarChangeFontSizeProperty = "Chart.LineTool.Toolbar.ChangeFontSizeProperty",
	ChartLineToolToolbarChangeLineStyleToDashed = "Chart.LineTool.Toolbar.ChangeLineStyleToDashed",
	ChartLineToolToolbarChangeLineStyleToDotted = "Chart.LineTool.Toolbar.ChangeLineStyleToDotted",
	ChartLineToolToolbarChangeLineStyleToSolid = "Chart.LineTool.Toolbar.ChangeLineStyleToSolid",
	ChartMarksToggleVisibility = "Chart.Marks.ToggleVisibility",
	ChartMoveChartInLayout = "Chart.MoveChartInLayout",
	ChartMoveChartInLayoutBack = "Chart.MoveChartInLayout.Back",
	ChartMoveChartInLayoutForward = "Chart.MoveChartInLayout.Forward",
	ChartObjectTreeShow = "Chart.ObjectTree.Show",
	ChartPaneControlsDeletePane = "Chart.PaneControls.DeletePane",
	ChartPaneControlsMaximizePane = "Chart.PaneControls.MaximizePane",
	ChartPaneControlsMinimizePane = "Chart.PaneControls.MinimizePane",
	ChartPaneControlsMovePaneDown = "Chart.PaneControls.MovePaneDown",
	ChartPaneControlsMovePaneUp = "Chart.PaneControls.MovePaneUp",
	ChartPaneControlsCollapsePane = "Chart.PaneControls.CollapsePane",
	ChartPaneControlsRestorePane = "Chart.PaneControls.RestorePane",
	ChartPriceScaleLabels = "Chart.PriceScale.Labels",
	ChartPriceScaleLabelsToggleBidAskLabelsVisibility = "Chart.PriceScale.Labels.ToggleBidAskLabelsVisibility",
	ChartPriceScaleLabelsToggleHighLowPriceLabelsVisibility = "Chart.PriceScale.Labels.ToggleHighLowPriceLabelsVisibility",
	ChartPriceScaleLabelsToggleAveragePriceLabelVisibility = "Chart.PriceScale.Labels.ToggleAveragePriceLabelVisibility",
	ChartPriceScaleLabelsToggleIndicatorsNameLabelsVisibility = "Chart.PriceScale.Labels.ToggleIndicatorsNameLabelsVisibility",
	ChartPriceScaleLabelsToggleIndicatorsValueLabelsVisibility = "Chart.PriceScale.Labels.ToggleIndicatorsValueLabelsVisibility",
	ChartPriceScaleLabelsToggleNoOverlappingLabelsVisibility = "Chart.PriceScale.Labels.ToggleNoOverlappingLabelsVisibility",
	ChartPriceScaleLabelsToggleSeriesLastValueVisibility = "Chart.PriceScale.Labels.ToggleSeriesLastValueVisibility",
	ChartPriceScaleLabelsToggleSymbolNameLabelsVisibility = "Chart.PriceScale.Labels.ToggleSymbolNameLabelsVisibility",
	ChartPriceScaleLabelsToggleSymbolPrevCloseValueVisibility = "Chart.PriceScale.Labels.ToggleSymbolPrevCloseValueVisibility",
	ChartPriceScaleMergeAllScales = "Chart.PriceScale.MergeAllScales",
	ChartPriceScaleMergeAllScalesToLeft = "Chart.PriceScale.MergeAllScalesToLeft",
	ChartPriceScaleMergeAllScalesToRight = "Chart.PriceScale.MergeAllScalesToRight",
	ChartPriceScaleMoveToLeft = "Chart.PriceScale.MoveToLeft",
	ChartPriceScaleMoveToRight = "Chart.PriceScale.MoveToRight",
	ChartPriceScaleReset = "Chart.PriceScale.Reset",
	ChartPriceScaleToggleAddOrderPlusButtonVisibility = "Chart.PriceScale.ToggleAddOrderPlusButtonVisibility",
	ChartPriceScaleToggleAutoScale = "Chart.PriceScale.ToggleAutoScale",
	ChartPriceScaleToggleAutoScaleSeriesOnly = "Chart.PriceScale.ToggleAutoScaleSeriesOnly",
	ChartPriceScaleToggleCountdownToBarCloseVisibility = "Chart.PriceScale.ToggleCountdownToBarCloseVisibility",
	ChartPriceScaleToggleIndexedTo100 = "Chart.PriceScale.ToggleIndexedTo100",
	ChartPriceScaleToggleInvertScale = "Chart.PriceScale.ToggleInvertScale",
	ChartPriceScaleToggleLogarithmic = "Chart.PriceScale.ToggleLogarithmic",
	ChartPriceScaleTogglePercentage = "Chart.PriceScale.TogglePercentage",
	ChartPriceScaleToggleRegular = "Chart.PriceScale.ToggleRegular",
	ChartRedo = "Chart.Redo",
	ChartRemoveAllIndicators = "Chart.RemoveAllIndicators",
	ChartRemoveAllIndicatorsAndLineTools = "Chart.RemoveAllIndicatorsAndLineTools",
	ChartRemoveAllLineTools = "Chart.RemoveAllLineTools",
	ChartScalesReset = "Chart.Scales.Reset",
	ChartScalesToggleLockPriceToBarRatio = "Chart.Scales.ToggleLockPriceToBarRatio",
	ChartScrollToLineTool = "Chart.ScrollToLineTool",
	ChartSelectedObjectHide = "Chart.SelectedObject.Hide",
	ChartSelectedObjectRemove = "Chart.SelectedObject.Remove",
	ChartSelectedObjectShow = "Chart.SelectedObject.Show",
	ChartSelectedObjectShowSettingsDialog = "Chart.SelectedObject.ShowSettingsDialog",
	ChartSelectedObjectToggleLocked = "Chart.SelectedObject.ToggleLocked",
	ChartSeriesPriceScaleToggleAutoScale = "Chart.Series.PriceScale.ToggleAutoScale",
	ChartSeriesPriceScaleToggleIndexedTo100 = "Chart.Series.PriceScale.ToggleIndexedTo100",
	ChartSeriesPriceScaleToggleInvertPriceScale = "Chart.Series.PriceScale.ToggleInvertPriceScale",
	ChartSeriesPriceScaleToggleLogarithmic = "Chart.Series.PriceScale.ToggleLogarithmic",
	ChartSeriesPriceScaleTogglePercentage = "Chart.Series.PriceScale.TogglePercentage",
	ChartSeriesPriceScaleToggleRegular = "Chart.Series.PriceScale.ToggleRegular",
	ChartSessionBreaksToggleVisibility = "Chart.SessionBreaks.ToggleVisibility",
	ChartSourceChangePriceScale = "Chart.Source.ChangePriceScale",
	ChartSourceMergeDown = "Chart.Source.MergeDown",
	ChartSourceMergeUp = "Chart.Source.MergeUp",
	ChartSourceMoveToNoScale = "Chart.Source.MoveToNoScale",
	ChartSourceMoveToOtherScale = "Chart.Source.MoveToOtherScale",
	ChartSourceMoveToPane = "Chart.Source.MoveToPane",
	ChartSourceUnmergeDown = "Chart.Source.UnmergeDown",
	ChartSourceUnmergeUp = "Chart.Source.UnmergeUp",
	ChartSourceVisualOrder = "Chart.Source.VisualOrder",
	ChartSourceVisualOrderBringForward = "Chart.Source.VisualOrder.BringForward",
	ChartSourceVisualOrderBringToFront = "Chart.Source.VisualOrder.BringToFront",
	ChartSourceVisualOrderSendBackward = "Chart.Source.VisualOrder.SendBackward",
	ChartSourceVisualOrderSendToBack = "Chart.Source.VisualOrder.SendToBack",
	ChartTimeScaleReset = "Chart.TimeScale.Reset",
	ChartUndo = "Chart.Undo",
	ObjectsTreeCreateGroup = "ObjectsTree.CreateGroup",
	ObjectsTreeRemoveItem = "ObjectsTree.RemoveItem",
	ObjectsTreeRenameItem = "ObjectsTree.RenameItem",
	ObjectsTreeToggleItemLocked = "ObjectsTree.ToggleItemLocked",
	ObjectsTreeToggleItemVisibility = "ObjectsTree.ToggleItemVisibility",
	TradingCancelOrder = "Trading.CancelOrder",
	TradingClosePosition = "Trading.ClosePosition",
	TradingCustomActionId = "Trading.CustomActionId",
	TradingDomePlaceLimitOrder = "Trading.DomePlaceLimitOrder",
	TradingDomePlaceMarketOrder = "Trading.DomePlaceMarketOrder",
	TradingDomePlaceStopLimitOrder = "Trading.DomePlaceStopLimitOrder",
	TradingDomePlaceStopOrder = "Trading.DomePlaceStopOrder",
	TradingEditOrder = "Trading.EditOrder",
	TradingModifyPosition = "Trading.ModifyPosition",
	TradingReversePosition = "Trading.ReversePosition",
	TradingSellBuyButtonsToggleVisibility = "Trading.SellBuyButtonsToggleVisibility",
	TradingTradeFromChart = "Trading.TradeFromChart",
	TradingNoOverlapMode = "Trading.NoOverlapMode"
}
export declare const enum ChartStyle {
	Bar = 0,
	Candle = 1,
	Line = 2,
	Area = 3,
	Renko = 4,
	Kagi = 5,
	PnF = 6,
	LineBreak = 7,
	HeikinAshi = 8,
	HollowCandle = 9,
	Baseline = 10,
	HiLo = 12,
	Column = 13
}
export declare const enum ConnectionStatus {
	Connected = 1,
	Connecting = 2,
	Disconnected = 3,
	Error = 4
}
export declare const enum FilledAreaType {
	TypePlots = "plot_plot",
	TypeHlines = "hline_hline"
}
export declare const enum MenuItemType {
	Separator = "separator",
	Action = "action"
}
export declare const enum NotificationType {
	Error = 0,
	Success = 1
}
export declare const enum OhlcStudyPlotStyle {
	OhlcBars = "ohlc_bars",
	OhlcCandles = "ohlc_candles"
}
export declare const enum OrderStatus {
	Canceled = 1,
	Filled = 2,
	Inactive = 3,
	Placing = 4,
	Rejected = 5,
	Working = 6
}
export declare const enum OrderStatusFilter {
	All = 0,
	Canceled = 1,
	Filled = 2,
	Inactive = 3,
	Rejected = 5,
	Working = 6
}
export declare const enum OrderTicketFocusControl {
	LimitPrice = 1,
	StopPrice = 2,
	TakeProfit = 3,
	StopLoss = 4,
	Quantity = 5
}
export declare const enum OrderType {
	Limit = 1,
	Market = 2,
	Stop = 3,
	StopLimit = 4
}
export declare const enum ParentType {
	Order = 1,
	Position = 2,
	Trade = 3
}
export declare const enum PriceScaleMode {
	Normal = 0,
	Log = 1,
	Percentage = 2,
	IndexedTo100 = 3
}
export declare const enum SeriesStyle {
	Bars = 0,
	Candles = 1,
	Line = 2,
	Area = 3,
	HeikenAshi = 8,
	HollowCandles = 9,
	Baseline = 10,
	HiLo = 12,
	Column = 13,
	Renko = 4,
	Kagi = 5,
	PointAndFigure = 6,
	LineBreak = 7
}
export declare const enum Side {
	Buy = 1,
	Sell = -1
}
export declare const enum StandardFormatterName {
	Date = "date",
	DateOrDateTime = "dateOrDateTime",
	Default = "default",
	Fixed = "fixed",
	VariablePrecision = "variablePrecision",
	FormatQuantity = "formatQuantity",
	FormatPrice = "formatPrice",
	FormatPriceForexSup = "formatPriceForexSup",
	IntegerSeparated = "integerSeparated",
	LocalDate = "localDate",
	LocalDateOrDateTime = "localDateOrDateTime",
	OrderSettings = "orderSettings",
	Percentage = "percentage",
	Pips = "pips",
	Profit = "profit",
	ProfitInInstrumentCurrency = "profitInInstrumentCurrency",
	PosSettings = "posSettings",
	Side = "side",
	PositionSide = "positionSide",
	Status = "status",
	Symbol = "symbol",
	Text = "text",
	TextNoWrap = "textNoWrap",
	TradeSettings = "tradeSettings",
	Type = "type",
	MarginPercent = "marginPercent"
}
export declare const enum StudyPlotType {
	Line = "line",
	Colorer = "colorer",
	BarColorer = "bar_colorer",
	BgColorer = "bg_colorer",
	TextColorer = "text_colorer",
	OhlcColorer = "ohlc_colorer",
	CandleWickColorer = "wick_colorer",
	CandleBorderColorer = "border_colorer",
	UpColorer = "up_colorer",
	DownColorer = "down_colorer",
	Shapes = "shapes",
	Chars = "chars",
	Arrows = "arrows",
	DataOffset = "dataoffset",
	OhlcOpen = "ohlc_open",
	OhlcHigh = "ohlc_high",
	OhlcLow = "ohlc_low",
	OhlcClose = "ohlc_close",
	AlertCondition = "alertcondition"
}
export declare const enum TimeFrameType {
	PeriodBack = "period-back",
	TimeRange = "time-range"
}
export declare const enum VisibilityType {
	AlwaysOn = "alwaysOn",
	VisibleOnMouseOver = "visibleOnMouseOver",
	AlwaysOff = "alwaysOff"
}
export declare const widget: ChartingLibraryWidgetConstructor;
/**
 * Returns a build version string. For example "CL v23.012 (internal id e0d59dc3 @ 2022-08-23T06:07:00.808Z)".
 *
 * @returns The build version string.
 */
export declare function version(): string;
export declare type AccountId = Nominal<string, "AccountID">;
export declare type ActionMetaInfo = ActionDescriptionWithCallback | MenuSeparator;
export declare type AvailableSaveloadVersions = "1.0" | "1.1";
export declare type CellAlignment = "left" | "right";
/**
 * A chart action ID.
 */
export declare type ChartActionId = "chartProperties" | "compareOrAdd" | "scalesProperties" | "paneObjectTree" | "insertIndicator" | "symbolSearch" | "changeInterval" | "timeScaleReset" | "chartReset" | "seriesHide" | "studyHide" | "lineToggleLock" | "lineHide" | "scaleSeriesOnly" | "drawingToolbarAction" | "stayInDrawingModeAction" | "hideAllMarks" | "showCountdown" | "showSeriesLastValue" | "showSymbolLabelsAction" | "showStudyLastValue" | "showStudyPlotNamesAction" | "undo" | "redo" | "paneRemoveAllStudiesDrawingTools" | "showSymbolInfoDialog";
export declare type ContextMenuItemsProcessor = (items: readonly IActionVariant[], actionsFactory: ActionsFactory) => Promise<readonly IActionVariant[]>;
export declare type ContextMenuRendererFactory = (items: readonly IActionVariant[], params: CreateContextMenuParams, onDestroy: () => void) => Promise<IContextMenuRenderer>;
export declare type CreateButtonOptions = CreateHTMLButtonOptions | CreateTradingViewStyledButtonOptions;
export declare type CustomStudyFormatter = Omit<INumberFormatter, "parse">;
/**
 * Factory function that can be implemented to create custom study formatters.
 */
export declare type CustomStudyFormatterFactory = (format: CustomStudyFormatterFormat, symbolInfo: LibrarySymbolInfo | null) => CustomStudyFormatter | null;
export declare type CustomTranslateFunction = (key: string, options?: TranslateOptions) => string | null;
export declare type DateFormat = keyof typeof dateFormatFunctions;
export declare type Direction = "buy" | "sell";
export declare type DomeCallback = (data: DOMData) => void;
export declare type DrawingEventType = "click" | "move" | "remove" | "hide" | "show" | "create" | "properties_changed" | "points_changed";
export declare type DropdownUpdateParams = Partial<Omit<DropdownParams, "align">>;
export declare type EditObjectDialogObjectType = "mainSeries" | "drawing" | "study" | "other";
export declare type EmptyCallback = () => void;
export declare type EntityId = Nominal<string, "EntityId">;
export declare type ErrorCallback = (reason: string) => void;
export declare type FieldDescriptor = TimeFieldDescriptor | UserTimeFieldDescriptor | SeriesFieldDescriptor | StudyFieldDescriptor;
export declare type GetMarksCallback<T> = (marks: T[]) => void;
export declare type GetNewsFunction = (symbol: string, callback: (response: GetNewsResponse) => void) => void;
export declare type GroupLockState = "Locked" | "Unlocked" | "Partial";
export declare type GroupVisibilityState = "Visible" | "Invisible" | "Partial";
export declare type HeaderWidgetButtonsMode = "fullsize" | "compact" | "adaptive";
export declare type HistoryCallback = (bars: Bar[], meta?: HistoryMetadata) => void;
export declare type IActionVariant = IAction | ISeparator;
export declare type IBasicDataFeed = IDatafeedChartApi & IExternalDatafeed;
export declare type INumberFormatter = IFormatter<number>;
export declare type InputFieldValidator = (value: any) => InputFieldValidatorResult;
export declare type InputFieldValidatorResult = PositiveBaseInputFieldValidatorResult | NegativeBaseInputFieldValidatorResult;
export declare type LanguageCode = "ar" | "zh" | "cs" | "da_DK" | "nl_NL" | "en" | "et_EE" | "fr" | "de" | "el" | "he_IL" | "hu_HU" | "id_ID" | "it" | "ja" | "ko" | "fa" | "pl" | "pt" | "ro" | "ru" | "sk_SK" | "es" | "sv" | "th" | "tr" | "vi" | "no" | "ms_MY" | "zh_TW";
export declare type LayoutType = SingleChartLayoutType | MultipleChartsLayoutType;
export declare type LegendMode = "horizontal" | "vertical";
export declare type MarkConstColors = "red" | "green" | "blue" | "yellow";
export declare type MultipleChartsLayoutType = "2h" | "2v" | "2-1" | "3s" | "3h" | "3v" | "4" | "6" | "8" | "1-2" | "3r" | "4h" | "4v" | "4s" | "1-3" | "2-2" | "1-4" | "5s" | "6c" | "8c";
/**
 * This is the generic type useful for declaring a nominal type,
 * which does not structurally matches with the base type and
 * the other types declared over the same base type
 *
 * Usage:
 * @example
 * type Index = Nominal<number, 'Index'>;
 * // let i: Index = 42; // this fails to compile
 * let i: Index = 42 as Index; // OK
 * @example
 * type TagName = Nominal<string, 'TagName'>;
 */
export declare type Nominal<T, Name extends string> = T & {
	[Symbol.species]: Name;
};
export declare type OnActionExecuteHandler = (action: IAction) => void;
export declare type OnActionUpdateHandler = (action: IAction) => void;
export declare type OnReadyCallback = (configuration: DatafeedConfiguration) => void;
export declare type Order = PlacedOrder | BracketOrder;
export declare type PageName = "watchlist_details_news" | "data_window" | "object_tree";
export declare type PineJS = any;
export declare type PlotShapeId = "shape_arrow_down" | "shape_arrow_up" | "shape_circle" | "shape_cross" | "shape_xcross" | "shape_diamond" | "shape_flag" | "shape_square" | "shape_label_down" | "shape_label_up" | "shape_triangle_down" | "shape_triangle_up";
export declare type QuoteData = QuoteOkData | QuoteErrorData;
export declare type QuotesCallback = (data: QuoteData[]) => void;
export declare type ResolutionString = Nominal<string, "ResolutionString">;
export declare type ResolveCallback = (symbolInfo: LibrarySymbolInfo) => void;
export declare type RssNewsFeedItem = RssNewsFeedInfo | RssNewsFeedInfo[];
export declare type SearchSymbolsCallback = (items: SearchSymbolResultItem[]) => void;
export declare type SeriesEventType = "price_scale_changed";
export declare type SeriesFormat = "price" | "volume";
export declare type SeriesFormatterFactory = (symbolInfo: LibrarySymbolInfo | null, minTick: string) => ISymbolValueFormatter | null;
export declare type SeriesPriceScale = "new-left" | "new-right" | "no-scale" | EntityId;
export declare type ServerTimeCallback = (serverTime: number) => void;
/**
 * A time range to set. The end `to` value is optional.
 *
 * When the optional `to` value is omitted then the value will
 * fallback to the timestamp of the latest bar on the chart.
 */
export declare type SetVisibleTimeRange = Omit<VisibleTimeRange, "to"> & Partial<Pick<VisibleTimeRange, "to">>;
export declare type ShapePoint = StickedPoint | PricedPoint | TimePoint;
export declare type ShapesGroupId = Nominal<string, "ShapesGroupId">;
export declare type SingleChartLayoutType = "s";
export declare type StudyEventType = "remove" | "price_scale_changed";
export declare type StudyInputId = Nominal<string, "StudyInputId">;
export declare type StudyInputValue = string | number | boolean;
export declare type StudyOhlcPlotPreferences = StudyOhlcPlotBarsStylePreferences | StudyOhlcPlotCandlesStylePreferences;
export declare type StudyOverrideValueType = string | number | boolean;
export declare type StudyPlotInfo = StudyArrowsPlotInfo | StudyCharsPlotInfo | StudyColorerPlotInfo | StudyDataOffsetPlotInfo | StudyLinePlotInfo | StudyOhlcPlotInfo | StudyShapesPlotInfo | StudyBarColorerPlotInfo | StudyBgColorerPlotInfo | StudyTextColorerPlotInfo | StudyOhlcColorerPlotInfo | StudyCandleWickColorerPlotInfo | StudyCandleBorderColorerPlotInfo | StudyUpColorerPlotInfo | StudyDownColorerPlotInfo | StudyAlertConditionPlotInfo;
export declare type StudyPlotPreferences = StudyLinePlotPreferences | StudyShapesPlotPreferences | StudyCharsPlotPreferences | StudyArrowsPlotPreferences;
/**
 * Price scale to display a study on.
 */
export declare type StudyPriceScale = "new-left" | "new-right" | "no-scale" | "as-series";
export declare type StudyStyleValues = Omit<StudyStyleInfo, "defaults">;
export declare type SubscribeBarsCallback = (bar: Bar) => void;
export declare type SupportedLineTools = "text" | "anchored_text" | "note" | "anchored_note" | "signpost" | "double_curve" | "arc" | "icon" | "arrow_up" | "arrow_down" | "arrow_left" | "arrow_right" | "price_label" | "price_note" | "arrow_marker" | "flag" | "vertical_line" | "horizontal_line" | "cross_line" | "horizontal_ray" | "trend_line" | "info_line" | "trend_angle" | "arrow" | "ray" | "extended" | "parallel_channel" | "disjoint_angle" | "flat_bottom" | "pitchfork" | "schiff_pitchfork_modified" | "schiff_pitchfork" | "balloon" | "inside_pitchfork" | "pitchfan" | "gannbox" | "gannbox_square" | "gannbox_fixed" | "gannbox_fan" | "fib_retracement" | "fib_trend_ext" | "fib_speed_resist_fan" | "fib_timezone" | "fib_trend_time" | "fib_circles" | "fib_spiral" | "fib_speed_resist_arcs" | "fib_channel" | "xabcd_pattern" | "cypher_pattern" | "abcd_pattern" | "callout" | "triangle_pattern" | "3divers_pattern" | "head_and_shoulders" | "fib_wedge" | "elliott_impulse_wave" | "elliott_triangle_wave" | "elliott_triple_combo" | "elliott_correction" | "elliott_double_combo" | "cyclic_lines" | "time_cycles" | "sine_line" | "long_position" | "short_position" | "forecast" | "date_range" | "price_range" | "date_and_price_range" | "bars_pattern" | "ghost_feed" | "projection" | "rectangle" | "rotated_rectangle" | "circle" | "ellipse" | "triangle" | "polyline" | "path" | "curve" | "cursor" | "dot" | "arrow_cursor" | "eraser" | "measure" | "zoom" | "brush" | "highlighter" | "regression_trend" | "fixed_range_volume_profile";
export declare type SymbolSearchCompleteOverrideFunction = (symbol: string) => Promise<string>;
export declare type SymbolType = "stock" | "index" | "forex" | "futures" | "bitcoin" | "crypto" | "undefined" | "expression" | "spread" | "cfd" | "economic" | "equity" | "dr" | "bond" | "right" | "warrant" | "fund" | "structured";
export declare type TextInputFieldValidator = (value: string) => InputFieldValidatorResult;
export declare type ThemeName = "Light" | "Dark";
export declare type TickMarkType = 
/**
 * The start of the year (e.g. it's the first tick mark in a year).
 */
"Year"
/**
 * The start of the month (e.g. it's the first tick mark in a month).
 */
 | "Month"
/**
 * A day of the month.
 */
 | "DayOfMonth"
/**
 * A time without seconds.
 */
 | "Time"
/**
 * A time with seconds.
 */
 | "TimeWithSeconds";
export declare type TimeFrameValue = TimeFramePeriodBack | TimeFrameTimeRange;
export declare type TimeframeOption = string | {
	from: number;
	to: number;
};
export declare type Timezone = "Etc/UTC" | CustomTimezones;
export declare type TimezoneId = CustomTimezones | "Etc/UTC" | "exchange";
export declare type TradableSolutions = ChangeAccountSolution | ChangeSymbolSolution;
export declare type TradingDialogCustomField = CheckboxFieldMetaInfo | TextWithCheckboxFieldMetaInfo | CustomComboBoxMetaInfo;
export declare type VisiblePlotsSet = "ohlcv" | "ohlc" | "c";
export declare type WatchListSymbolListAddedCallback = (listId: string, symbols: string[]) => void;
export declare type WatchListSymbolListChangedCallback = (listId: string) => void;
export declare type WatchListSymbolListRemovedCallback = (listId: string) => void;
export declare type WatchListSymbolListRenamedCallback = (listId: string, oldName: string, newName: string) => void;
export declare type WatchedValueCallback<T> = (value: T) => void;
export interface AccessList {
	type: "black" | "white";
	tools: AccessListItem[];
}
export interface AccessListItem {
	name: string;
	grayed?: boolean;
}
export interface AccountManagerColumn {
	label: string;
	alignment?: CellAlignment;
	formatter?: StandardFormatterName | "orderSettings" | "posSettings" | string;
	property: string;
	sortProp?: string;
	notSortable?: boolean;
	help?: string;
	highlightDiff?: boolean;
	notHideable?: boolean;
	hideByDefault?: boolean;
	tooltipProperty?: string;
	isCapitalize?: boolean;
	showZeroValues?: boolean;
}
export interface AccountManagerInfo {
	accountTitle: string;
	summary: AccountManagerSummaryField[];
	orderColumns: OrderTableColumn[];
	orderColumnsSorting?: SortingParameters;
	historyColumns?: AccountManagerColumn[];
	historyColumnsSorting?: SortingParameters;
	positionColumns?: AccountManagerColumn[];
	tradeColumns?: AccountManagerColumn[];
	pages: AccountManagerPage[];
	possibleOrderStatuses?: OrderStatus[];
	marginUsed?: IWatchedValue<number>;
	contextMenuActions?(contextMenuEvent: MouseEvent | TouchEvent, activePageActions: ActionMetaInfo[]): Promise<ActionMetaInfo[]>;
}
export interface AccountManagerPage {
	id: string;
	title: string;
	tables: AccountManagerTable[];
}
export interface AccountManagerSummaryField {
	text: string;
	wValue: IWatchedValueReadonly<any>;
	formatter?: string;
	isDefault?: boolean;
}
export interface AccountManagerTable {
	id: string;
	title?: string;
	columns: AccountManagerColumn[];
	initialSorting?: SortingParameters;
	changeDelegate: ISubscription<(data: {}) => void>;
	flags?: AccountManagerTableFlags;
	getData(paginationLastId?: string | number): Promise<{}[]>;
}
export interface AccountManagerTableFlags {
	supportPagination?: boolean;
}
export interface ActionDescription {
	text?: "-" | string;
	separator?: boolean;
	shortcut?: string;
	tooltip?: string;
	checked?: boolean;
	checkedStateSource?: () => boolean;
	checkable?: boolean;
	enabled?: boolean;
	externalLink?: boolean;
	icon?: string;
}
export interface ActionDescriptionWithCallback extends ActionDescription {
	action: (a?: ActionDescription) => void;
}
export interface ActionOptions extends Partial<Omit<ActionState, "actionId">>, Pick<ActionState, "actionId"> {
	/**
	 * A function which will be called when an action should be executed (e.g. when a user clicks on the item).
	 */
	onExecute?: OnActionExecuteHandler;
}
export interface ActionState {
	/**
	 * Human-readable, non-unique ID of an action item. Similar to {@link label}, but language-agnostic.
	 */
	actionId: ActionId;
	active: boolean;
	/**
	 * Text title of an action
	 */
	label: string;
	/**
	 * Whether an action is disabled or not (disabled actions are usually cannot be executed and displayed grayed out)
	 */
	disabled: boolean;
	/**
	 * Sub-items of an action
	 */
	subItems: IActionVariant[];
	/**
	 * Whether an action should have a checkbox next to it.
	 */
	checkable: boolean;
	/**
	 * If {@link checkable} is `true` then whether current state is checked or not.
	 */
	checked: boolean;
	/**
	 * A hint of an action.
	 */
	hint?: string;
	/**
	 * A string of SVG icon for an action. A string should be a string representation of SVG (not a path/URL).
	 */
	icon?: string;
	/**
	 * If {@link checkable} is `true` then an icon to be used when {@link checked} is `true`.
	 */
	iconChecked?: string;
	/**
	 * Whether an action is still in loading state (it means that it's data is not ready yet).
	 * Usually in this case a spinner/loader will be displayed instead of this action.
	 */
	loading: boolean;
	/**
	 * A string that represents a shortcut hint for this action.
	 */
	shortcutHint?: string;
}
export interface ActionsFactory {
	/**
	 * Creates an action with provided options.
	 */
	createAction: (options: ActionOptions) => IUpdatableAction;
	/**
	 * Creates an action that will wait for a promise to get its options.
	 * In terms of GUI until a promise is resolved the loader/spinner will be displayed.
	 */
	createAsyncAction: (loader: () => Promise<ActionOptions>) => IUpdatableAction;
	/**
	 * Creates a separator item.
	 */
	createSeparator: () => ISeparator;
}
export interface AdditionalSymbolInfoField {
	title: string;
	propertyName: string;
}
export interface AreaStylePreferences {
	color1: string;
	color2: string;
	linecolor: string;
	linestyle: number;
	linewidth: number;
	transparency: number;
}
export interface AvailableZOrderOperations {
	bringForwardEnabled: boolean;
	bringToFrontEnabled: boolean;
	sendBackwardEnabled: boolean;
	sendToBackEnabled: boolean;
}
export interface Bar {
	time: number;
	open: number;
	high: number;
	low: number;
	close: number;
	volume?: number;
}
export interface BarStylePreferences {
	upColor: string;
	downColor: string;
	barColorsOnPrevClose: boolean;
	dontDrawOpen: boolean;
	thinBars: boolean;
}
export interface BaseInputFieldValidatorResult {
	valid: boolean;
}
export interface BaselineStylePreferences {
	topFillColor1: string;
	topFillColor2: string;
	bottomFillColor1: string;
	bottomFillColor2: string;
	topLineColor: string;
	bottomLineColor: string;
	baselineColor: string;
	topLineWidth: number;
	bottomLineWidth: number;
	transparency: number;
	baseLevelPercentage: number;
}
export interface BracketOrder extends PlacedOrder {
	parentId: string;
	parentType: ParentType;
}
export interface Brackets {
	stopLoss?: number;
	takeProfit?: number;
	trailingStopPips?: number;
}
export interface BrokerConfigFlags {
	supportDisplayBrokerNameInSymbolSearch?: boolean;
	showQuantityInsteadOfAmount?: boolean;
	supportOrderBrackets?: boolean;
	supportTrailingStop?: boolean;
	supportPositions?: boolean;
	supportPositionBrackets?: boolean;
	supportTradeBrackets?: boolean;
	supportTrades?: boolean;
	supportClosePosition?: boolean;
	supportCloseTrade?: boolean;
	supportModifyOrderPrice?: boolean;
	supportEditAmount?: boolean;
	supportModifyBrackets?: boolean;
	supportLevel2Data?: boolean;
	supportDOM?: boolean;
	supportMultiposition?: boolean;
	supportPLUpdate?: boolean;
	supportReversePosition?: boolean;
	supportNativeReversePosition?: boolean;
	supportMarketOrders?: boolean;
	supportLimitOrders?: boolean;
	supportStopOrders?: boolean;
	supportStopLimitOrders?: boolean;
	supportDemoLiveSwitcher?: boolean;
	supportMarketBrackets?: boolean;
	supportSymbolSearch?: boolean;
	supportModifyDuration?: boolean;
	supportModifyTrailingStop?: boolean;
	supportMargin?: boolean;
	calculatePLUsingLast?: boolean;
	supportPlaceOrderPreview?: boolean;
	supportModifyOrderPreview?: boolean;
	supportLeverage?: boolean;
	supportOrdersHistory?: boolean;
	supportAddBracketsToExistingOrder?: boolean;
	supportBalances?: boolean;
	closePositionCancelsOrders?: boolean;
	supportOnlyPairPositionBrackets?: boolean;
	supportCryptoExchangeOrderTicket?: boolean;
	supportConfirmations?: boolean;
	/** Does broker need to display position's PL in instrument's currency */
	positionPLInInstrumentCurrency?: boolean;
	/** Does broker support partial position closing */
	supportPartialClosePosition?: boolean;
	/** Does broker support partial trade closing */
	supportPartialCloseTrade?: boolean;
	/** Cancelling a bracket cancels it's oco pair */
	supportCancellingBothBracketsOnly?: boolean;
	/** Does broker support crypto brackets */
	supportCryptoBrackets?: boolean;
	/** Does broker need to show notifications log */
	showNotificationsLog?: boolean;
	/**
	 * Whether stop orders should behave like Market-if-touched in both directions.
	 * Enabling this flag removes the direction check from the order dialog.
	 */
	supportStopOrdersInBothDirections?: boolean;
	/**
	 * Enabling this flag prevents the check of stop price direction from the stop limit order dialog.
	 */
	supportStopLimitOrdersInBothDirections?: boolean;
	/** Does broker support executions */
	supportExecutions?: boolean;
	requiresFIFOCloseTrades?: boolean;
	/**
	 * @deprecated
	 */
	supportBrackets?: boolean;
	/**
	 * Use supportModifyOrderPrice, supportEditAmount and supportModifyBrackets instead.
	 * @deprecated
	 */
	supportModifyOrder?: boolean;
}
export interface BrokerCustomUI {
	showOrderDialog?: (order: OrderTemplate | Order, focus?: OrderTicketFocusControl) => Promise<boolean>;
	showPositionDialog?: (position: Position | Trade, brackets: Brackets, focus?: OrderTicketFocusControl) => Promise<boolean>;
	showCancelOrderDialog?: (order: Order) => Promise<boolean>;
	showClosePositionDialog?: (position: Position) => Promise<boolean>;
}
export interface CandleStylePreferences {
	upColor: string;
	downColor: string;
	drawWick: boolean;
	drawBorder: boolean;
	drawBody: boolean;
	borderColor: string;
	borderUpColor: string;
	borderDownColor: string;
	wickColor: string;
	wickUpColor: string;
	wickDownColor: string;
	barColorsOnPrevClose: boolean;
}
export interface ChangeAccountSolution {
	changeAccount: AccountId;
}
export interface ChangeSymbolSolution {
	changeSymbol: string;
}
export interface ChangeThemeOptions {
	disableUndo: boolean;
}
export interface ChartData {
	id: string;
	name: string;
	symbol: string;
	resolution: ResolutionString;
	content: string;
}
export interface ChartMetaInfo {
	id: number;
	name: string;
	symbol: string;
	resolution: ResolutionString;
	timestamp: number;
}
export interface ChartingLibraryWidgetConstructor {
	new (options: ChartingLibraryWidgetOptions | TradingTerminalWidgetOptions): IChartingLibraryWidget;
}
export interface ChartingLibraryWidgetOptions {
	/** @deprecated */
	container_id?: string;
	container: HTMLElement | string;
	datafeed: IBasicDataFeed | (IBasicDataFeed & IDatafeedQuotesApi);
	interval: ResolutionString;
	symbol?: string;
	auto_save_delay?: number;
	autosize?: boolean;
	debug?: boolean;
	disabled_features?: string[];
	drawings_access?: AccessList;
	enabled_features?: string[];
	fullscreen?: boolean;
	height?: number;
	library_path?: string;
	locale: LanguageCode;
	numeric_formatting?: NumericFormattingParams;
	saved_data?: object;
	saved_data_meta_info?: SavedStateMetaInfo;
	studies_access?: AccessList;
	study_count_limit?: number;
	symbol_search_request_delay?: number;
	timeframe?: TimeframeOption;
	timezone?: "exchange" | Timezone;
	toolbar_bg?: string;
	width?: number;
	charts_storage_url?: string;
	charts_storage_api_version?: AvailableSaveloadVersions;
	client_id?: string;
	user_id?: string;
	load_last_chart?: boolean;
	studies_overrides?: StudyOverrides;
	customFormatters?: CustomFormatters;
	custom_formatters?: CustomFormatters;
	overrides?: Overrides;
	snapshot_url?: string;
	preset?: "mobile";
	time_frames?: TimeFrameItem[];
	custom_css_url?: string;
	custom_font_family?: string;
	favorites?: Favorites;
	save_load_adapter?: IExternalSaveLoadAdapter;
	loading_screen?: LoadingScreenOptions;
	settings_adapter?: ISettingsAdapter;
	theme?: ThemeName;
	compare_symbols?: CompareSymbol[];
	custom_indicators_getter?: (PineJS: PineJS) => Promise<readonly CustomIndicator[]>;
	additional_symbol_info_fields?: AdditionalSymbolInfoField[];
	header_widget_buttons_mode?: HeaderWidgetButtonsMode;
	context_menu?: ContextMenuOptions;
	time_scale?: TimeScaleOptions;
	custom_translate_function?: CustomTranslateFunction;
	symbol_search_complete?: SymbolSearchCompleteOverrideFunction;
	settings_overrides?: Overrides;
}
export interface CheckboxFieldMetaInfo extends CustomFieldMetaInfoBase {
	inputType: "Checkbox";
	value: boolean;
	supportModify?: boolean;
	help?: string;
}
export interface ClientSnapshotOptions {
	backgroundColor: string;
	borderColor: string;
	font: string;
	fontSize: number;
	legendMode: LegendMode;
	hideResolution: boolean;
}
export interface ColumnStylePreferences {
	upColor: string;
	downColor: string;
	barColorsOnPrevClose: boolean;
}
export interface CompareSymbol {
	symbol: string;
	title: string;
}
export interface ContextMenuItem {
	position: "top" | "bottom";
	text: string;
	click: EmptyCallback;
}
export interface ContextMenuOptions {
	items_processor?: ContextMenuItemsProcessor;
	/**
	 * This API is experimental and might be changed significantly in the future releases.
	 */
	renderer_factory?: ContextMenuRendererFactory;
}
export interface ContextMenuPosition {
	clientX: number;
	clientY: number;
	touches?: readonly {
		clientX: number;
		clientY: number;
	}[];
	/**
	 * Tells what side of the context menu widget should be used to "attach" to a provided x coordinate.
	 * If the value is `undefined`, then you may treat it based on whether it is rtl or not (e.g. `'right'` for rtl and `'left'` otherwise).
	 */
	attachToXBy?: "left" | "right";
	/**
	 * Tells what side of the context menu widget should be used to "attach" to a provided y coordinate:
	 * - `'auto'` means similar to `'top'` but the menu could be expanded above the coordinate if needed (if there is no enough space to place it below)
	 * - `'auto-strict'` means `'top'` if the whole menu fits the space below the coordinate and `'bottom'` otherwise (see {@link boxHeight})
	 * - `'top'` means that the menu should be placed to the bottom of y coordinate (the menu should be attached by its bottom to y coordinate)
	 * - `'bottom'` means that the menu should be placed above y coordinate (the menu should be attached by its top to y coordinate)
	 *
	 * You may treat `undefined` as `'auto'`.
	 */
	attachToYBy?: "auto" | "auto-strict" | "top" | "bottom";
	/**
	 * The height of a box the context menu should avoid while calculating coordinates (see {@link attachToYBy}).
	 *
	 * You may treat `undefined` as `0`.
	 */
	boxHeight?: number;
}
export interface CreateContextMenuParams {
	menuName: string;
	detail?: {
		type: "series";
		id: string;
	} | {
		type: "study";
		id: string | null;
	} | {
		type: "shape";
		id: number | string | null;
	} | {
		type: "groupOfShapes";
		id: string | null;
	};
}
export interface CreateHTMLButtonOptions {
	align: "left" | "right";
	useTradingViewStyle: false;
}
/**
 * Options for creating a multipoint shape.
 */
export interface CreateMultipointShapeOptions<TOverrides extends object> extends CreateShapeOptionsBase<TOverrides> {
	/**
	 * A shape to create.
	 */
	shape?: Exclude<SupportedLineTools, "cursor" | "dot" | "arrow_cursor" | "eraser" | "measure" | "zoom">;
}
/**
 * Options for creating a shape.
 */
export interface CreateShapeOptions<TOverrides extends object> extends CreateShapeOptionsBase<TOverrides> {
	/**
	 * A shape to create.
	 */
	shape?: "arrow_up" | "arrow_down" | "flag" | "vertical_line" | "horizontal_line" | "long_position" | "short_position" | "icon";
	/**
	 * An optional study ID of the owner study.
	 */
	ownerStudyId?: EntityId;
}
/**
 * Options for creating a shape.
 */
export interface CreateShapeOptionsBase<TOverrides extends object> {
	text?: string;
	lock?: boolean;
	/**
	 * Disable/enable selecting the shape.
	 */
	disableSelection?: boolean;
	/**
	 * Disable/enable saving the shape.
	 */
	disableSave?: boolean;
	/**
	 * Disable/enable undoing the creation of the shape.
	 */
	disableUndo?: boolean;
	/**
	 * Shape properties overrides.
	 */
	overrides?: TOverrides;
	/**
	 * Create the shape in front of all other shapes, or behind all other shapes.
	 */
	zOrder?: "top" | "bottom";
	/**
	 * Enable/disable showing the shape in the objects tree.
	 */
	showInObjectsTree?: boolean;
	/**
	 * An entity ID that can be used to associate the shape with a study.
	 */
	ownerStudyId?: EntityId;
	/**
	 * Enable/disable filling the shape with color (if the shape supports filling).
	 */
	filled?: boolean;
}
/**
 * Options for creating a study.
 */
export interface CreateStudyOptions {
	checkLimit?: boolean;
	priceScale?: StudyPriceScale;
	allowChangeCurrency?: boolean;
	allowChangeUnit?: boolean;
	disableUndo?: boolean;
}
/**
 * Options for creating a study template.
 */
export interface CreateStudyTemplateOptions {
	/**
	 * An optional boolean flag to include the symbol in the saved state.
	 */
	saveSymbol?: boolean;
	/**
	 * An optional boolean flag to include the interval in the saved state.
	 */
	saveInterval?: boolean;
}
export interface CreateTradingViewStyledButtonOptions {
	align: "left" | "right";
	useTradingViewStyle: true;
	text: string;
	title?: string;
	onClick?: () => void;
}
/**
 * Crosshair move event information.
 */
export interface CrossHairMovedEventParams {
	/**
	 * The time coordinate of the crosshair.
	 */
	time: number;
	/**
	 * The price coordinate of the crosshair.
	 */
	price: number;
}
export interface CryptoBalance {
	symbol: string;
	total: number;
	available: number;
	reserved?: number;
	value?: number;
	valueCurrency?: string;
	longName?: string;
	btcValue?: number;
}
export interface CurrencyItem {
	id: string;
	code: string;
	logoUrl?: string;
	description?: string;
}
export interface CustomComboBoxItem {
	text: string;
	value: string;
}
export interface CustomComboBoxMetaInfo extends CustomInputFieldMetaInfo {
	inputType: "ComboBox";
	items: CustomComboBoxItem[];
}
export interface CustomFieldMetaInfoBase {
	inputType: string;
	id: string;
	title: string;
	value?: any;
	saveToSettings?: boolean;
}
export interface CustomFields {
	[key: string]: any;
}
export interface CustomFormatter {
	format(date: Date): string;
	formatLocal(date: Date): string;
}
/**
 * Formatters used to adjust the displayed format of the date and time values.
 */
export interface CustomFormatters {
	timeFormatter: CustomFormatter;
	dateFormatter: CustomFormatter;
	tickMarkFormatter?: (date: Date, tickMarkType: TickMarkType) => string;
	priceFormatterFactory?: SeriesFormatterFactory;
	studyFormatterFactory?: CustomStudyFormatterFactory;
}
export interface CustomIndicator {
	readonly name: string;
	readonly metainfo: any;
	readonly constructor: any;
}
export interface CustomInputFieldMetaInfo extends CustomFieldMetaInfoBase {
	preventModify?: boolean;
	placeHolder?: string;
	validator?: InputFieldValidator;
	customInfo?: any;
}
export interface CustomInputFieldsValues {
	[fieldId: string]: TextWithCheckboxValue | boolean | string | any;
}
/**
 * Study format description used in custom study formatters.
 */
export interface CustomStudyFormatterFormat {
	/**
	 * The format of the plot.
	 */
	type: "price" | "volume" | "percent";
	/**
	 * The format precision.
	 */
	precision?: number;
}
export interface DOMData {
	snapshot: boolean;
	asks: DOMLevel[];
	bids: DOMLevel[];
}
export interface DOMLevel {
	price: number;
	volume: number;
}
export interface DatafeedConfiguration {
	exchanges?: Exchange[];
	supported_resolutions?: ResolutionString[];
	units?: Record<string, Unit[]>;
	currency_codes?: (string | CurrencyItem)[];
	supports_marks?: boolean;
	supports_time?: boolean;
	supports_timescale_marks?: boolean;
	symbols_types?: DatafeedSymbolType[];
}
export interface DatafeedQuoteValues {
	ch?: number;
	chp?: number;
	short_name?: string;
	exchange?: string;
	description?: string;
	lp?: number;
	ask?: number;
	bid?: number;
	spread?: number;
	open_price?: number;
	high_price?: number;
	low_price?: number;
	prev_close_price?: number;
	volume?: number;
	original_name?: string;
	[valueName: string]: string | number | undefined;
}
export interface DatafeedSymbolType {
	name: string;
	value: string;
}
export interface DefaultContextMenuActionsParams {
}
export interface DefaultDropdownActionsParams {
	tradingProperties?: boolean;
	showHowToUse?: boolean;
	restoreConfirmations?: boolean;
}
export interface DialogParams<CallbackType> {
	title: string;
	body: string;
	callback: CallbackType;
}
export interface DropdownItem {
	title: string;
	onSelect: () => void;
}
export interface DropdownParams {
	title: string;
	items: DropdownItem[];
	tooltip?: string;
	icon?: string;
	align?: "right" | "left";
}
export interface EditObjectDialogEventParams {
	objectType: EditObjectDialogObjectType;
	scriptTitle: string;
}
export interface EntityInfo {
	id: EntityId;
	name: string;
}
export interface ErrorFormatterParseResult extends FormatterParseResult {
	error?: string;
	res: false;
}
export interface Exchange {
	value: string;
	name: string;
	desc: string;
}
export interface Execution extends CustomFields {
	symbol: string;
	price: number;
	qty: number;
	side: Side;
	time: number;
}
export interface ExportDataOptions {
	/**
	 * Optional timestamp of the first exported bar.
	 */
	from?: number;
	/**
	 * Optional timestamp of the last exported bar.
	 */
	to?: number;
	/**
	 * If true then each exported data item will include a time value.
	 *
	 * @default true
	 */
	includeTime?: boolean;
	/**
	 * If true then each exported data item will include a user time value.
	 *
	 * @default false
	 */
	includeUserTime?: boolean;
	/**
	 * If true then the exported data will include open, high, low, close values from the main series.
	 *
	 * @default true
	 */
	includeSeries?: boolean;
	/**
	 * If true then the exported data will include formatted value as displayed to the user.
	 *
	 * @default false
	 */
	includeDisplayedValues?: boolean;
	/**
	 * If true then each exported data item will include a value for the specified studies.
	 */
	includedStudies: readonly string[] | "all";
}
export interface ExportedData {
	schema: FieldDescriptor[];
	data: Float64Array[];
	displayedData: string[][];
}
export interface Favorites {
	intervals: ResolutionString[];
	chartTypes: string[];
}
export interface FormatterParseResult {
	res: boolean;
}
export interface GetNewsResponse {
	title?: string;
	newsItems: NewsItem[];
}
export interface GrayedObject {
	type: "drawing" | "study";
	name: string;
}
export interface HHistPreferences {
	colors: string[];
	transparencies: number[];
	visible: boolean;
	percentWidth: number;
	showValues: boolean;
	valuesColor: string;
	direction: HHistDirection;
}
export interface HeikinAshiStylePreferences {
	upColor: string;
	downColor: string;
	drawWick: boolean;
	drawBorder: boolean;
	drawBody: boolean;
	borderColor: string;
	borderUpColor: string;
	borderDownColor: string;
	wickColor: string;
	wickUpColor: string;
	wickDownColor: string;
	showRealLastPrice: boolean;
	barColorsOnPrevClose: boolean;
}
export interface HiLoStylePreferences {
	color: string;
	showBorders: boolean;
	borderColor: string;
	showLabels: boolean;
	labelColor: string;
	fontSize: number;
	drawBody: boolean;
}
export interface HistoryMetadata {
	noData?: boolean;
	nextTime?: number | null;
}
export interface HollowCandleStylePreferences {
	upColor: string;
	downColor: string;
	drawWick: boolean;
	drawBorder: boolean;
	drawBody: boolean;
	borderColor: string;
	borderUpColor: string;
	borderDownColor: string;
	wickColor: string;
	wickUpColor: string;
	wickDownColor: string;
}
export interface HorizLinePreferences {
	visible: boolean;
	width: number;
	color: string;
	style: LineStyle;
}
export interface IAction extends IMenuItem {
	readonly type: MenuItemType.Action;
	/**
	 * A method which will be called when an action should be executed (e.g. when a user clicks on the item)
	 */
	execute(): void;
	/**
	 * @returns Returns a state object of the action.
	 */
	getState(): Readonly<ActionState>;
	/**
	 * @returns A subscription for an event when an action is updated.
	 */
	onUpdate(): ISubscription<OnActionUpdateHandler>;
}
export interface IBoxedValue<T> extends IBoxedValueReadOnly<T> {
	setValue(value: T): void;
}
export interface IBoxedValueReadOnly<T> {
	value(): T;
}
export interface IBrokerCommon {
	chartContextMenuActions(context: TradeContext, options?: DefaultContextMenuActionsParams): Promise<ActionMetaInfo[]>;
	isTradable(symbol: string): Promise<boolean | IsTradableResult>;
	connectionStatus(): ConnectionStatus;
	orders(): Promise<Order[]>;
	ordersHistory?(): Promise<Order[]>;
	positions?(): Promise<Position[]>;
	trades?(): Promise<Trade[]>;
	executions(symbol: string): Promise<Execution[]>;
	symbolInfo(symbol: string): Promise<InstrumentInfo>;
	accountManagerInfo(): AccountManagerInfo;
	formatter?(symbol: string, alignToMinMove: boolean): Promise<INumberFormatter>;
	spreadFormatter?(symbol: string): Promise<INumberFormatter>;
	quantityFormatter?(symbol: string): Promise<INumberFormatter>;
	getOrderDialogOptions?(symbol: string): Promise<OrderDialogOptions | undefined>;
	getPositionDialogOptions?(): PositionDialogOptions | undefined;
}
export interface IBrokerConnectionAdapterFactory {
	createDelegate<T extends Function>(): IDelegate<T>;
	createWatchedValue<T>(value?: T): IWatchedValue<T>;
	createPriceFormatter(priceScale?: number, minMove?: number, fractional?: boolean, minMove2?: number): IPriceFormatter;
}
export interface IBrokerConnectionAdapterHost {
	factory: IBrokerConnectionAdapterFactory;
	defaultFormatter(symbol: string, alignToMinMove: boolean): Promise<INumberFormatter>;
	numericFormatter(decimalPlaces: number): Promise<INumberFormatter>;
	quantityFormatter(decimalPlaces?: number): Promise<INumberFormatter>;
	defaultContextMenuActions(context: TradeContext, params?: DefaultContextMenuActionsParams): Promise<ActionMetaInfo[]>;
	defaultDropdownMenuActions(options?: Partial<DefaultDropdownActionsParams>): ActionMetaInfo[];
	sellBuyButtonsVisibility(): IWatchedValue<boolean> | null;
	domPanelVisibility(): IWatchedValue<boolean> | null;
	orderPanelVisibility(): IWatchedValue<boolean> | null;
	silentOrdersPlacement(): IWatchedValue<boolean>;
	patchConfig(config: Partial<BrokerConfigFlags>): void;
	setDurations(durations: OrderDurationMetaInfo[]): void;
	orderUpdate(order: Order): void;
	orderPartialUpdate(id: string, orderChanges: Partial<Order>): void;
	positionUpdate(position: Position, isHistoryUpdate?: boolean): void;
	positionPartialUpdate(id: string, positionChanges: Partial<Position>): void;
	tradeUpdate(trade: Trade, isHistoryUpdate?: boolean): void;
	tradePartialUpdate(id: string, tradeChanges: Partial<Trade>): void;
	executionUpdate(execution: Execution): void;
	currentAccountUpdate(): void;
	realtimeUpdate(symbol: string, data: TradingQuotes): void;
	plUpdate(positionId: string, pl: number): void;
	pipValueUpdate(symbol: string, pipValues: PipValues): void;
	tradePLUpdate(tradeId: string, pl: number): void;
	equityUpdate(equity: number): void;
	marginAvailableUpdate(marginAvailable: number): void;
	cryptoBalanceUpdate(symbol: string, balance: CryptoBalance): void;
	domeUpdate(symbol: string, equity: DOMData): void;
	showOrderDialog?<T extends PreOrder>(order: T, focus?: OrderTicketFocusControl): Promise<boolean>;
	showNotification(title: string, text: string, notificationType?: NotificationType): void;
	showCancelOrderDialog(orderId: string, handler: () => Promise<void>): Promise<void>;
	showCancelMultipleOrdersDialog(symbol: string, side: Side, qty: number, handler: () => Promise<void>): Promise<void>;
	showCancelBracketsDialog(orderId: string, handler: () => Promise<void>): Promise<void>;
	showCancelMultipleBracketsDialog(orderId: string, handler: () => Promise<void>): Promise<void>;
	showReversePositionDialog(position: string, handler: () => Promise<boolean>): Promise<boolean>;
	showPositionBracketsDialog(position: Position | Trade, brackets: Brackets, focus: OrderTicketFocusControl): Promise<boolean>;
	setButtonDropdownActions(descriptions: ActionMetaInfo[]): void;
	activateBottomWidget(): Promise<void>;
	showTradingProperties(): void;
	getSymbolMinTick(symbol: string): Promise<number>;
	showMessageDialog(title: string, text: string, textHasHTML: boolean): void;
	showConfirmDialog(title: string, content: string | string[], mainButtonText?: string, cancelButtonText?: string, showDisableConfirmationsCheckbox?: boolean): Promise<boolean>;
	showSimpleConfirmDialog(title: string, content: string | string[], mainButtonText?: string, cancelButtonText?: string, showDisableConfirmationsCheckbox?: boolean): Promise<boolean>;
}
export interface IBrokerTerminal extends IBrokerWithoutRealtime {
	subscribeRealtime(symbol: string): void;
	unsubscribeRealtime(symbol: string): void;
}
export interface IBrokerWithoutRealtime extends IBrokerCommon {
	subscribeDOME?(symbol: string): void;
	unsubscribeDOME?(symbol: string): void;
	placeOrder(order: PreOrder, confirmId?: string): Promise<PlaceOrderResult>;
	previewOrder?(order: PreOrder): Promise<OrderPreviewResult>;
	modifyOrder(order: Order, confirmId?: string): Promise<void>;
	cancelOrder(orderId: string): Promise<void>;
	cancelOrders(symbol: string, side: Side | undefined, ordersIds: string[]): Promise<void>;
	reversePosition?(positionId: string): Promise<void>;
	closePosition?(positionId: string, amount?: number): Promise<void>;
	closeTrade?(tradeId: string, amount?: number): Promise<void>;
	editPositionBrackets?(positionId: string, brackets: Brackets, customFields?: CustomInputFieldsValues): Promise<void>;
	editTradeBrackets?(tradeId: string, brackets: Brackets): Promise<void>;
	leverageInfo?(leverageInfoParams: LeverageInfoParams): Promise<LeverageInfo>;
	setLeverage?(leverageSetParams: LeverageSetParams): Promise<LeverageSetResult>;
	previewLeverage?(leverageSetParams: LeverageSetParams): Promise<LeveragePreviewResult>;
	/**
	 * @deprecated Brokers should always send PL and equity updates
	 */
	subscribePL?(positionId: string): void;
	subscribeEquity?(): void;
	subscribeMarginAvailable?(symbol: string): void;
	subscribePipValue?(symbol: string): void;
	unsubscribePipValue?(symbol: string): void;
	unsubscribeMarginAvailable?(symbol: string): void;
	/**
	 * @deprecated
	 */
	unsubscribePL?(positionId: string): void;
	unsubscribeEquity?(): void;
}
/**
 * The main chart API.
 */
export interface IChartWidgetApi {
	/**
	 * Get a subscription object for new data being loaded for the chart.
	 *
	 * @returns A subscription object for new data loaded for the chart.
	 */
	onDataLoaded(): ISubscription<() => void>;
	/**
	 * Get a subscription object for the chart symbol changing.
	 *
	 * @returns A subscription object for the chart symbol changing.
	 */
	onSymbolChanged(): ISubscription<() => void>;
	/**
	 * Get a subscription object for the chart interval (resolution) changing.
	 *
	 * @returns A subscription object for the chart interval (resolution) changing.
	 */
	onIntervalChanged(): ISubscription<(interval: ResolutionString, timeFrameParameters: {
		timeframe?: TimeFrameValue;
	}) => void>;
	/**
	 * Get a subscription object for the chart's visible range changing.
	 *
	 * @returns A subscription object for the chart's visible range changing.
	 */
	onVisibleRangeChanged(): ISubscription<(range: VisibleTimeRange) => void>;
	/**
	 * Get a subscription object for the chart type changing.
	 *
	 * @returns A subscription object for the chart type changing.
	 */
	onChartTypeChanged(): ISubscription<(chartType: SeriesStyle) => void>;
	/**
	 * Provide a callback function that will be called when chart data is loaded.
	 * If chart data is already loaded when this method is called then the callback is called immediately.
	 *
	 * @param callback A callback function called when chart data is loaded.
	 */
	dataReady(callback: () => void): boolean;
	/**
	 * Get a subscription object for the crosshair moving over the chart.
	 *
	 * @returns A subscription object for the crosshair moving over the chart.
	 */
	crossHairMoved(): ISubscription<(params: CrossHairMovedEventParams) => void>;
	/**
	 * Scroll and/or scale the chart so a time range is visible.
	 *
	 * @param range A range that will be made visible.
	 * @param options Optional object of options for the new visible range.
	 * @returns A promise that is resolved when the range has been set.
	 */
	setVisibleRange(range: SetVisibleTimeRange, options?: SetVisibleRangeOptions): Promise<void>;
	/**
	 * Change the chart's symbol.
	 *
	 * @param symbol A symbol.
	 * @param callback An optional callback function. Called when the data for the new symbol has loaded.
	 */
	setSymbol(symbol: string, callback?: () => void): void;
	/**
	 * Change the chart's interval (resolution).
	 *
	 * @param symbol A resolution.
	 * @param callback An optional callback function. Called when the data for the new resolution has loaded.
	 */
	setResolution(resolution: ResolutionString, callback?: () => void): void;
	/**
	 * Change the chart's type.
	 *
	 * @param symbol A chart type.
	 * @param callback An optional callback function. Called when the chart type has changed and data has loaded.
	 */
	setChartType(type: SeriesStyle, callback?: () => void): void;
	/**
	 * Force the chart to re-request data.
	 * Before calling this function the `onResetCacheNeededCallback` callback from {@link IDatafeedChartApi.subscribeBars} should be called.
	 */
	resetData(): void;
	/**
	 * Execute an action.
	 *
	 * @param actionId An action ID.
	 */
	executeActionById(actionId: ChartActionId): void;
	/**
	 * Get the state of a checkable action.
	 * @param actionId An action ID.
	 * @returns `true` if the action is checked, `false` otherwise.
	 */
	getCheckableActionState(actionId: ChartActionId): boolean;
	/**
	 * Force the chart to re-request all bar marks and timescale marks.
	 */
	refreshMarks(): void;
	/**
	 * Remove all visible marks.
	 */
	clearMarks(): void;
	/**
	 * Get an array of IDs and name for all shapes on the chart.
	 *
	 * @returns An array of shape information.
	 */
	getAllShapes(): EntityInfo[];
	/**
	 * Get an array of IDs and names for all studies on the chart.
	 *
	 * @returns An array of shape information.
	 */
	getAllStudies(): EntityInfo[];
	/**
	 * Get the chart's price to bar ratio.
	 *
	 * @returns The ratio or `null` if no ratio is defined.
	 */
	getPriceToBarRatio(): number | null;
	/**
	 * Set the chart's price to bar ratio.
	 *
	 * @param ratio The new price to bar ratio.
	 * @param options Optional undo options.
	 */
	setPriceToBarRatio(ratio: number, options?: UndoOptions): void;
	/**
	 * Get the locked/unlocked state of the chart's price to bar ratio.
	 */
	isPriceToBarRatioLocked(): boolean;
	/**
	 * Lock or unlock the chart's price to bar ratio.
	 *
	 * @param value `true` to lock, `false` to unlock.
	 * @param options Optional undo options.
	 */
	setPriceToBarRatioLocked(value: boolean, options?: UndoOptions): void;
	/**
	 * Get an array of the heigh of all panes.
	 *
	 * @returns An array of heights.
	 */
	getAllPanesHeight(): number[];
	/**
	 * Set the height for each pane in the order provided.
	 *
	 * @param heights An array of heights.
	 */
	setAllPanesHeight(heights: readonly number[]): void;
	maximizeChart(): void;
	restoreChart(): void;
	/**
	 * Get an object with operations available for the specified set of entities.
	 *
	 * @param sources An array of entity IDs.
	 */
	availableZOrderOperations(sources: readonly EntityId[]): AvailableZOrderOperations;
	/**
	 * Move the group to the bottom of the Z-order.
	 *
	 * @param sources An array of source IDs.
	 */
	sendToBack(entities: readonly EntityId[]): void;
	/**
	 * Move the sources to the top of the Z-order.
	 *
	 * @param sources An array of source IDs.
	 */
	bringToFront(sources: readonly EntityId[]): void;
	/**
	 * Move the sources one level up in the Z-order.
	 *
	 * @param sources An array of source IDs.
	 */
	bringForward(sources: readonly EntityId[]): void;
	/**
	 * Move the sources one level down in the Z-order.
	 *
	 * @param sources An array of source IDs.
	 */
	sendBackward(sources: readonly EntityId[]): void;
	/**
	 * @deprecated Use shape/study API instead.
	 * @see {@link getStudyById}
	 * @see {@link getShapeById}
	 */
	setEntityVisibility(entityId: EntityId, isVisible: boolean): void;
	createStudy<TOverrides extends StudyOverrides>(name: string, forceOverlay?: boolean, lock?: boolean, inputs?: Record<string, StudyInputValue>, overrides?: TOverrides, options?: CreateStudyOptions): Promise<EntityId | null>;
	/**
	 * @deprecated Prefer `createStudy` function that relies on named properties for `inputs`.
	 * @see {@link createStudy}
	 */
	createStudy<TStudyInputValue extends StudyInputValue, TOverrides extends StudyOverrides>(name: string, forceOverlay?: boolean, lock?: boolean, inputs?: TStudyInputValue[], overrides?: TOverrides, options?: CreateStudyOptions): Promise<EntityId | null>;
	/**
	 * Get a study by ID.
	 *
	 * @param entityId The study ID.
	 * @returns An API object for interacting with the study.
	 */
	getStudyById(entityId: EntityId): IStudyApi;
	/**
	 * Get the main series.
	 *
	 * @returns An API object for interacting with the main series.
	 */
	getSeries(): ISeriesApi;
	/**
	 * Create a new single point shape.
	 *
	 * @param point A point. The location of the new shape.
	 * @param options A options object for the new shape.
	 * @returns The ID of the new shape if it was created successfully, or null otherwise.
	 */
	createShape<TOverrides extends object>(point: ShapePoint, options: CreateShapeOptions<TOverrides>): EntityId | null;
	/**
	 * Create a new multi point shape.
	 *
	 * @param points An array of points that define the shape.
	 * @param options An options object for the new shape.
	 * @returns The ID of the new shape if it was created successfully, or null otherwise.
	 */
	createMultipointShape<TOverrides extends object>(points: ShapePoint[], options: CreateMultipointShapeOptions<TOverrides>): EntityId | null;
	/**
	 * Get a shape by ID.
	 *
	 * @param entityId A shape ID.
	 * @returns An API object for interacting with the shape.
	 */
	getShapeById(entityId: EntityId): ILineDataSourceApi;
	/**
	 * Remove an entity (e.g. shape or study) from the chart.
	 * @param entityId The ID of the entity.
	 * @param options Optional undo options.
	 */
	removeEntity(entityId: EntityId, options?: UndoOptions): void;
	/**
	 * Remove all shapes from the chart.
	 */
	removeAllShapes(): void;
	/**
	 * Remove all studies from the chart.
	 */
	removeAllStudies(): void;
	/**
	 * Get an API object for interacting with the selection.
	 */
	selection(): ISelectionApi;
	/**
	 * Show the properties dialog for a study or shape.
	 *
	 * @param studyId An ID of the study or shape.
	 */
	showPropertiesDialog(studyId: EntityId): void;
	/**
	 * Save the current study template to a object.
	 *
	 * @param options An object of study template options.
	 * @returns A study template object.
	 */
	createStudyTemplate(options: CreateStudyTemplateOptions): object;
	/**
	 * Apply a study template to the chart.
	 *
	 * @param template A study template object.
	 */
	applyStudyTemplate(template: object): void;
	/**
	 * Create a new trading order on the chart.
	 *
	 * @param options Optional undo options.
	 * @returns An API object for interacting with the order.
	 */
	createOrderLine(options?: UndoOptions): IOrderLineAdapter;
	/**
	 * Creates a new trading position on the chart.
	 *
	 * @param options Optional undo options.
	 * @returns An API object for interacting with the position.
	 */
	createPositionLine(options?: UndoOptions): IPositionLineAdapter;
	/**
	 * Creates a new trade execution on the chart.
	 *
	 * @param options Optional undo options.
	 * @returns An API object for interacting with the execution.
	 */
	createExecutionShape(options?: UndoOptions): IExecutionLineAdapter;
	/**
	 * Get the name of the current symbol.
	 */
	symbol(): string;
	/**
	 * Get an extended information object for the current symbol.
	 */
	symbolExt(): SymbolExt;
	/**
	 * Get the current resolution (interval).
	 */
	resolution(): ResolutionString;
	/**
	 * Get the current visible time range.
	 */
	getVisibleRange(): VisibleTimeRange;
	/**
	 * @deprecated Use Price Scale API instead
	 */
	getVisiblePriceRange(): VisiblePriceRange;
	/**
	 * @deprecated Use rightOffset from TimeScale API instead
	 */
	scrollPosition(): number;
	/**
	 * @deprecated Use defaultRightOffset from TimeScale API instead
	 */
	defaultScrollPosition(): number;
	priceFormatter(): INumberFormatter;
	chartType(): SeriesStyle;
	/**
	 * @deprecated Use Timezone API instead
	 * @see {@link getTimezoneApi}
	 */
	setTimezone(timezone: "exchange" | Timezone): void;
	/**
	 * @deprecated Use Timezone API instead
	 * @see {@link getTimezoneApi}
	 */
	getTimezone(): "exchange" | Timezone;
	/**
	 * Get an API object for interacting with the chart timezone.
	 */
	getTimezoneApi(): ITimezoneApi;
	/**
	 * Get an array of API objects for interacting with the chart panes.
	 */
	getPanes(): IPaneApi[];
	/**
	 * Export the current data from the chart.
	 *
	 * @param options Optional object of options to control the exported data.
	 * @returns A promise that resolves with the exported data.
	 */
	exportData(options?: Partial<ExportDataOptions>): Promise<ExportedData>;
	/**
	 * Check if the chart can be zoomed out using the {@link zoomOut} method.
	 *
	 * @returns `true` if the chart can be zoomed out.
	 */
	canZoomOut(): boolean;
	/**
	 * Zoom out. The method has the same effect as clicking on the "Zoom out" button.
	 */
	zoomOut(): void;
	/**
	 * Enable or disable zooming of the chart.
	 *
	 * @param enabled `true` to enable zooming, `false` to disable.
	 */
	setZoomEnabled(enabled: boolean): void;
	/**
	 * Enable or disable scrolling of the chart.
	 *
	 * @param enabled `true` to enable scrolling, `false` to disable.
	 */
	setScrollEnabled(enabled: boolean): void;
	/**
	 * Get an API object for interacting with groups of shapes.
	 */
	shapesGroupController(): IShapesGroupControllerApi;
	barTimeToEndOfPeriod(unixTime: number): number;
	endOfPeriodToBarTime(unixTime: number): number;
	/**
	 * Get an API object for interacting with the timescale.
	 */
	getTimeScale(): ITimeScaleApi;
	/**
	 * Check if bar selection mode is active or not.
	 *
	 * @returns `true` if active, `false` otherwise.
	 */
	isSelectBarRequested(): boolean;
	/**
	 * Switch the chart to bar selection mode.
	 *
	 * @returns A promise that resolves to the timestamp of a bar selected by the user. Rejects if the bar selection was already requested or is cancelled.
	 */
	requestSelectBar(): Promise<number>;
	/**
	 * Cancel any active bar selection requests.
	 */
	cancelSelectBar(): void;
}
/**
 * The main interface for interacting with the library.
 */
export interface IChartingLibraryWidget {
	/**
	 * A promise that resolves if and when the header is ready to be used.
	 */
	headerReady(): Promise<void>;
	/**
	 * The library will call `callback` when the chart is ready to be used.
	 *
	 * @param callback A function that will be called when the chart is ready to be used.
	 */
	onChartReady(callback: EmptyCallback): void;
	/**
	 * The library will call `callback` when a greyed-out line tool or study is clicked.
	 *
	 * @param callback A function that will be called when a greyed-out line tool or study is clicked.
	 */
	onGrayedObjectClicked(callback: (obj: GrayedObject) => void): void;
	/**
	 * The library will call `callback` when the `shortCut` keys are input.
	 *
	 * Use a string separated by '+' for shortcuts using an alphabet character (A to Z) with optional modifiers (ctrl, shift, alt).
	 * Use a number for shortcuts using non-alphabet character without modifiers.
	 * If you don't know the key code you need you can use resources like [keycode.info](https://keycode.info), or [MDN](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode) to check.
	 * Use an array of literal key codes and modifier strings for shortcuts using non-alphabet characters with optional modifier strings.
	 *
	 * @param shortCut A number, a string, or an array of number and string.
	 * @param callback A function that will be called when the `shortCut` keys are input.
	 * @example
	 * ```javascript
	 * widget.onShortcut("alt+s", function() {
	 *   widget.chart().executeActionById("symbolSearch");
	 * });
	 *
	 * // F1
	 * widget.onShortcut(112, function() {
	 *   widget.chart().executeActionById("symbolSearch");
	 * });
	 *
	 * // ctrl+shift+\
	 * widget.onShortcut(['ctrl', 'shift', 220], function() {
	 * 	 widget.chart().executeActionById("symbolSearch");
	 * });
	 * ```
	 */
	onShortcut(shortCut: string | number | (string | number)[], callback: EmptyCallback): void;
	/**
	 * Subscribe to library events.
	 *
	 * @param event A event to subscribe to.
	 * @param callback A callback that will be called when the event happens.
	 */
	subscribe<EventName extends keyof SubscribeEventsMap>(event: EventName, callback: SubscribeEventsMap[EventName]): void;
	/**
	 * Unsubscribe from library events.
	 *
	 * @param event A event to unsubscribe from.
	 * @param callback A callback to unsubscribe. Must be the same reference as a callback passed to {@link subscribe}.
	 */
	unsubscribe<EventName extends keyof SubscribeEventsMap>(event: EventName, callback: SubscribeEventsMap[EventName]): void;
	/**
	 * Get an API instance that can be used to interact with a chart.
	 *
	 * @param index Zero based index of the chart.
	 * @returns An API instance.
	 */
	chart(index?: number): IChartWidgetApi;
	/**
	 * Get the configured locale of the widget. For example `en`, `zh`, `ru`.
	 *
	 * @returns A code representing the locale of the widget.
	 */
	getLanguage(): LanguageCode;
	/**
	 * Set the symbol and resolution of the active chart.
	 * @param symbol A symbol to load.
	 * @param interval A interval (resolution) to load.
	 * @param callback A callback. Called when the symbol's data has finished loading.
	 */
	setSymbol(symbol: string, interval: ResolutionString, callback: EmptyCallback): void;
	/**
	 * Remove the widget and all its data from the page. The widget cannot be interacted with after it has been removed.
	 */
	remove(): void;
	/**
	 * Close all open context menus, pop-ups or dialogs.
	 */
	closePopupsAndDialogs(): void;
	/**
	 * Select a drawing or a cursor. It's the same as clicking on the corresponding button in the left toolbar.
	 *
	 * @param linetool A drawing or cursor to select.
	 * @param options An optional object with options. Currently only used for the 'icon' drawing.
	 */
	selectLineTool(linetool: "icon", options?: IconOptions): void;
	selectLineTool(linetool: Omit<"icon", SupportedLineTools>): void;
	selectLineTool(linetool: SupportedLineTools, options?: IconOptions): void;
	/**
	 * Get the currently selected drawing or cursor.
	 *
	 * @returns An identifier for drawing or cursor.
	 */
	selectedLineTool(): SupportedLineTools;
	/**
	 * Saves the chart state to a object. This method is part of the low-level save/load API.
	 *
	 * @param callback A function called with the chart state as the first argument.
	 */
	save(callback: (state: object) => void): void;
	/**
	 * Saves the chart state to a object. This method is part of the low-level save/load API.
	 *
	 * @param state A chart state object to load.
	 * @param extendedData A optional object of information about the saved state.
	 */
	load(state: object, extendedData?: SavedStateMetaInfo): void;
	/**
	 * Get a list of chart descriptions saved to the server for the current user.
	 *
	 * @param callback A function called with an array of saved chart information as the first argument.
	 */
	getSavedCharts(callback: (chartRecords: SaveLoadChartRecord[]) => void): void;
	/**
	 * Load a saved chart from the server.
	 *
	 * @param chartRecord A chart information object (returned by {@link getSavedCharts}).
	 */
	loadChartFromServer(chartRecord: SaveLoadChartRecord): void;
	/**
	 * Save the current chart to the server.
	 *
	 * @param onComplete An optional callback function called when the chart is successfully saved.
	 * @param onFail An optional callback function called when the chart fails to save.
	 * @param options An optional object of options for saving the chart.
	 */
	saveChartToServer(onComplete?: EmptyCallback, onFail?: EmptyCallback, options?: SaveChartToServerOptions): void;
	/**
	 * Remove a saved chart from the server.
	 *
	 * @param chartId A chart ID from a {@link SaveLoadChartRecord} (returned by {@link getSavedCharts}).
	 * @param onCompleteCallback A callback function called when the chart is successfully saved.
	 */
	removeChartFromServer(chartId: string, onCompleteCallback: EmptyCallback): void;
	/**
	 * The widget will call the callback function each time the widget wants to display a context menu.
	 * See also {@link ChartingLibraryWidgetOptions.context_menu}.
	 *
	 * @param callback A function called with the time and price of the location on the chart that triggered the context menu.
	 * The array of objects returned will add or remove items from the context menu.
	 */
	onContextMenu(callback: (unixTime: number, price: number) => ContextMenuItem[]): void;
	/**
	 * Create a button in the top toolbar. This should be called after {@link headerReady} has resolved.
	 * @param options A optional object of options for the button.
	 * @returns A `HTMLElement` you can customise.
	 */
	createButton(options?: CreateHTMLButtonOptions): HTMLElement;
	/**
	 * Create a button in the top toolbar. This should be called after {@link headerReady} has resolved.
	 * If the `title` option is provided then the title text will be shown in a tooltip on hover.
	 * If the `onClick` option is provided then the button will be clickable.
	 * @param options A optional object of options for the button.
	 * @returns `undefined`.
	 */
	createButton(options?: CreateTradingViewStyledButtonOptions): void;
	/**
	 * Create a button in the top toolbar. This should be called after {@link headerReady} has resolved.
	 * @param options A optional object of options for the button.
	 * @returns A `HTMLElement` if the `useTradingViewStyle` option if `false`. `undefined` if `useTradingViewStyle` is `true`.
	 */
	createButton(options?: CreateButtonOptions): HTMLElement | undefined;
	createDropdown(params: DropdownParams): Promise<IDropdownApi>;
	/**
	 * Show a dialog with custom title and text along with an "OK" buttons.
	 * @param params A object of options for the created dialog.
	 */
	showNoticeDialog(params: DialogParams<() => void>): void;
	/**
	 * Show a dialog with custom title and text along with "OK" and "CANCEL" buttons.
	 *
	 * @param params A object of options for the created dialog.
	 */
	showConfirmDialog(params: DialogParams<(confirmed: boolean) => void>): void;
	/**
	 * Show the "Load Chart Layout" dialog.
	 */
	showLoadChartDialog(): void;
	/**
	 * Show the "Copy Chart Layout" dialog.
	 */
	showSaveAsChartDialog(): void;
	/**
	 * Get the symbol and interval of the active chart.
	 */
	symbolInterval(): SymbolIntervalResult;
	/**
	 * Get the price formatter for the main series. You can use this to format prices as the char
	 */
	mainSeriesPriceFormatter(): INumberFormatter;
	/**
	 * Get an array of supported intervals (resolutions).
	 *
	 * @returns - An array of supported intervals. E.g. `['1D', '5D', '1Y']`.
	 */
	getIntervals(): string[];
	/**
	 * Get an array of the names of all supported studies. These names can be used when calling {@link createStudy}.
	 *
	 * @returns - An array of supported study names. E.g. `['Accumulation/Distribution', 'Accumulative Swing Index', 'Advance/Decline', ...]`.
	 */
	getStudiesList(): string[];
	/**
	 * Get an array of information about the inputs of a study.
	 *
	 * @param studyName The name of a study.
	 */
	getStudyInputs(studyName: string): StudyInputInfo[];
	/**
	 * Get information about the styles of a study.
	 *
	 * @param studyName The name of a study.
	 */
	getStudyStyles(studyName: string): StudyStyleInfo;
	/**
	 * Add a custom CSS file for the library to load.
	 *
	 * @param url A url to the custom CSS file. Should be absolute or relative to the `static` folder.
	 */
	addCustomCSSFile(url: string): void;
	/**
	 * Apply overrides to the chart without reloading. See also {@link ChartingLibraryWidgetOptions.overrides}.
	 *
	 * @param overrides An object of overrides to apply to the chart.
	 */
	applyOverrides<TOverrides extends StudyOverrides>(overrides: TOverrides): void;
	/**
	 * Apply overrides to study styles and inputs without reloading. See also {@link ChartingLibraryWidgetOptions.studies_overrides}.
	 *
	 * @param overrides An object of overrides to apply to the studies.
	 */
	applyStudiesOverrides(overrides: object): void;
	/**
	 * Trading Terminal only. Get a promise that resolves with an API object for interacting with the widgetbar (right sidebar) watchlist.
	 *
	 * @returns An API object for interacting with the widgetbar (right sidebar) watchlist.
	 */
	watchList(): Promise<IWatchListApi>;
	/**
	 * Trading Terminal only. Get a promise that resolves with an API object for interacting with the widgetbar (right sidebar) news widget.
	 *
	 * @returns An API object for interacting with the widgetbar (right sidebar) widget.
	 */
	news(): Promise<INewsApi>;
	/**
	 * Trading Terminal only. Get a promise that resolves with an API object for interacting with the widgetbar (right sidebar).
	 *
	 * @returns An API object for interacting with the widgetbar (right sidebar).
	 */
	widgetbar(): Promise<IWidgetbarApi>;
	/**
	 * Get an API object for interacting with the active chart.
	 *
	 * @returns An API object for interacting with the chart.
	 */
	activeChart(): IChartWidgetApi;
	/**
	 * Get the number of charts in the current layout.
	 *
	 * @returns A count of the charts in the current layout.
	 */
	chartsCount(): number;
	/**
	 * Get the current chart layout type.
	 *
	 * @returns A string representation of the current layout type. E.g. `'2h'` for two charts split vertically.
	 */
	layout(): LayoutType;
	/**
	 * Set the current chart layout type.
	 *
	 * @params layout A string representation of the new layout type. E.g. `'2h'` for two charts split vertically.
	 */
	setLayout(layout: LayoutType): void;
	/**
	 * Get the name of the current chart layout. The return value will be `undefined` if the current layout has not been saved.
	 *
	 * @returns A string of the name of the current chart layout.
	 */
	layoutName(): string;
	/**
	 * Change the theme of the chart.
	 *
	 * @param themeName A theme name.
	 * @param options An optional object of options for the theme.
	 * @returns A promise that resolves when the theme has been changed.
	 */
	changeTheme(themeName: ThemeName, options?: ChangeThemeOptions): Promise<void>;
	/**
	 * Get the current theme of the chart.
	 *
	 * @returns A theme name. The name of the current theme.
	 */
	getTheme(): ThemeName;
	/**
	 * Create a snapshot of the chart and upload it to the server.
	 * When it is ready callback functions subscribed to the `'onScreenshotReady'` event using {@link subscribe} will be called.
	 * The URL of the snapshot will be passed as an argument to the callback function.
	 */
	takeScreenshot(): void;
	/**
	 * Create a shapshot of the chart and return it as a canvas.
	 *
	 * @param options An optional object that customises the returned snapshot.
	 * @returns A promise containing a `HTMLCanvasElement` of the snapshot.
	 */
	takeClientScreenshot(options?: Partial<ClientSnapshotOptions>): Promise<HTMLCanvasElement>;
	/**
	 * Get a watched value that can be used to read/write/subscribe to the state of the "Lock All Drawing Tools" button.
	 *
	 * @returns A watched value of the state of the "Lock All Drawing Tools" button.
	 */
	lockAllDrawingTools(): IWatchedValue<boolean>;
	/**
	 * Get a watched value that can be used to read/write/subscribe to the state of the "Hide All Drawing Tools" button.
	 *
	 * @returns A watched value of the state of the "Hide All Drawing Tools" button.
	 */
	hideAllDrawingTools(): IWatchedValue<boolean>;
	/**
	 * Get a watched value that can be used to read/write/subscribe to the state of the magnet.
	 *
	 * @returns A watched value of the state of the magnet.
	 */
	magnetEnabled(): IWatchedValue<boolean>;
	/**
	 * Get a watched value that can be used to read/write/subscribe to the state of the magnet mode.
	 *
	 * @returns A watched value of the state of the magnet mode.
	 */
	magnetMode(): IWatchedValue<number>;
	/**
	 * Only available in Trading Terminal. Get a watched value that can be used to read/write/subscribe to the state of the symbol sync between charts.
	 *
	 * @returns A watched value of the state of the symbol sync.
	 */
	symbolSync(): IWatchedValue<boolean>;
	/**
	 * Only available in Trading Terminal. Get a watched value that can be used to read/write/subscribe to the state of the interval sync between charts.
	 *
	 * @returns A watched value of the state of the interval sync.
	 */
	intervalSync(): IWatchedValue<boolean>;
	/**
	 * Only available in Trading Terminal. Get a watched value that can be used to read/write/subscribe to the state of the crosshair sync between charts.
	 *
	 * @returns A watched value of the state of the crosshair sync.
	 */
	crosshairSync(): IWatchedValue<boolean>;
	/**
	 * Only available in Trading Terminal. Get a watched value that can be used to read/write/subscribe to the state of the time sync between charts.
	 *
	 * @returns A watched value of the state of the time sync.
	 */
	timeSync(): IWatchedValue<boolean>;
	/**
	 * Set the chart into fullscreen mode (if it isn't already).
	 */
	startFullscreen(): void;
	/**
	 * Set the chart into non-fullscreen mode (if it isn't already).
	 */
	exitFullscreen(): void;
	/**
	 * Get the state of the undo/redo stack.
	 */
	undoRedoState(): UndoRedoState;
	/**
	 * Get a watched value that can be used to read/write/subscribe to the state of the navigation buttons.
	 *
	 * @returns A watched value of the state of the navigation buttons.
	 */
	navigationButtonsVisibility(): IWatchedValue<VisibilityType>;
	/**
	 * Get a watched value that can be used to read/write/subscribe to the state of the pane buttons.
	 *
	 * @returns A watched value of the state of the pane buttons.
	 */
	paneButtonsVisibility(): IWatchedValue<VisibilityType>;
	/**
	 * Get a watched value that can be used to read/write/subscribe to the state of the date format.
	 *
	 * @returns A watched value of the state of the date format.
	 */
	dateFormat(): IWatchedValue<DateFormat>;
	/**
	 * Enable or disable debug mode.
	 *
	 * @param enabled A boolean flag. `true` to enable debug mode, `false` to disable.
	 */
	setDebugMode(enabled: boolean): void;
	supportedChartTypes(): IWatchedValueReadonly<ChartStyle[]>;
}
export interface IContextMenuRenderer {
	/**
	 * Displays the menu at the position {@link pos}.
	 */
	show(pos: ContextMenuPosition): void;
	/**
	 * hides the menu.
	 */
	hide(): void;
	/**
	 * @returns Returns whether the menu is currently displayed.
	 */
	isShown(): boolean;
}
export interface IDatafeedChartApi {
	getMarks?(symbolInfo: LibrarySymbolInfo, from: number, to: number, onDataCallback: GetMarksCallback<Mark>, resolution: ResolutionString): void;
	getTimescaleMarks?(symbolInfo: LibrarySymbolInfo, from: number, to: number, onDataCallback: GetMarksCallback<TimescaleMark>, resolution: ResolutionString): void;
	/**
	 * This function is called if configuration flag supports_time is set to true when chart needs to know the server time.
	 * The charting library expects callback to be called once.
	 * The time is provided without milliseconds. Example: 1445324591. It is used to display Countdown on the price scale.
	 */
	getServerTime?(callback: ServerTimeCallback): void;
	searchSymbols(userInput: string, exchange: string, symbolType: string, onResult: SearchSymbolsCallback): void;
	resolveSymbol(symbolName: string, onResolve: ResolveCallback, onError: ErrorCallback, extension?: SymbolResolveExtension): void;
	getBars(symbolInfo: LibrarySymbolInfo, resolution: ResolutionString, periodParams: PeriodParams, onResult: HistoryCallback, onError: ErrorCallback): void;
	subscribeBars(symbolInfo: LibrarySymbolInfo, resolution: ResolutionString, onTick: SubscribeBarsCallback, listenerGuid: string, onResetCacheNeededCallback: () => void): void;
	unsubscribeBars(listenerGuid: string): void;
	subscribeDepth?(symbol: string, callback: DomeCallback): string;
	unsubscribeDepth?(subscriberUID: string): void;
	getVolumeProfileResolutionForPeriod?(currentResolution: ResolutionString, from: number, to: number, symbolInfo: LibrarySymbolInfo): ResolutionString;
}
export interface IDatafeedQuotesApi {
	getQuotes(symbols: string[], onDataCallback: QuotesCallback, onErrorCallback: (msg: string) => void): void;
	subscribeQuotes(symbols: string[], fastSymbols: string[], onRealtimeCallback: QuotesCallback, listenerGUID: string): void;
	unsubscribeQuotes(listenerGUID: string): void;
}
export interface IDelegate<TFunc extends Function> extends ISubscription<TFunc> {
	fire: TFunc;
}
/**
 * # IDESTRYBLE
 * ```
 * 
 *          
 *                          
 *         x 1       destroy()    
 *                       
 *                   
 *  destroy()  x 1                
 * 
 * ```
 */
export interface IDestroyable {
	destroy(): void;
}
export interface IDropdownApi {
	applyOptions(options: DropdownUpdateParams): void;
	remove(): void;
}
export interface IExecutionLineAdapter {
	remove(): void;
	getPrice(): number;
	setPrice(value: number): this;
	getTime(): number;
	setTime(value: number): this;
	getDirection(): Direction;
	setDirection(value: Direction): this;
	getText(): string;
	setText(value: string): this;
	getTooltip(): string;
	setTooltip(value: string): this;
	getArrowHeight(): number;
	setArrowHeight(value: number): this;
	getArrowSpacing(): number;
	setArrowSpacing(value: number): this;
	getFont(): string;
	setFont(value: string): this;
	getTextColor(): string;
	setTextColor(value: string): this;
	getArrowColor(): string;
	setArrowColor(value: string): this;
}
export interface IExternalDatafeed {
	onReady(callback: OnReadyCallback): void;
}
export interface IExternalSaveLoadAdapter {
	getAllCharts(): Promise<ChartMetaInfo[]>;
	removeChart<T extends number | string>(id: T): Promise<void>;
	saveChart(chartData: ChartData): Promise<string>;
	getChartContent(chartId: number): Promise<string>;
	getAllStudyTemplates(): Promise<StudyTemplateMetaInfo[]>;
	removeStudyTemplate(studyTemplateInfo: StudyTemplateMetaInfo): Promise<void>;
	saveStudyTemplate(studyTemplateData: StudyTemplateData): Promise<void>;
	getStudyTemplateContent(studyTemplateInfo: StudyTemplateMetaInfo): Promise<string>;
	getDrawingTemplates(toolName: string): Promise<string[]>;
	loadDrawingTemplate(toolName: string, templateName: string): Promise<string>;
	removeDrawingTemplate(toolName: string, templateName: string): Promise<void>;
	saveDrawingTemplate(toolName: string, templateName: string, content: string): Promise<void>;
}
export interface IFormatter<T> {
	format(value?: T): string;
	parse?(value: string): ErrorFormatterParseResult | SuccessFormatterParseResult<T>;
}
export interface ILineDataSourceApi {
	isSelectionEnabled(): boolean;
	setSelectionEnabled(enable: boolean): void;
	isSavingEnabled(): boolean;
	setSavingEnabled(enable: boolean): void;
	isShowInObjectsTreeEnabled(): boolean;
	setShowInObjectsTreeEnabled(enabled: boolean): void;
	isUserEditEnabled(): boolean;
	setUserEditEnabled(enabled: boolean): void;
	bringToFront(): void;
	sendToBack(): void;
	getProperties(): Record<string, any>;
	setProperties(newProperties: object): void;
	getPoints(): PricedPoint[];
	setPoints(points: ShapePoint[]): void;
}
export interface IMenuItem {
	readonly type: MenuItemType;
	/**
	 * An unique ID of an action item. Could be used to distinguish actions between each other.
	 */
	readonly id: string;
}
export interface INewsApi {
	refresh(): void;
}
export interface IObservable<T> {
	subscribe(callback: (value: T) => void): void;
	unsubscribe(callback: (value: T) => void): void;
}
export interface IObservableValue<T> extends IBoxedValue<T>, IObservable<T> {
}
export interface IObservableValueReadOnly<T> extends IBoxedValueReadOnly<T>, IObservable<T> {
}
export interface IOrderLineAdapter {
	remove(): void;
	onModify(callback: () => void): this;
	onModify<T>(data: T, callback: (data: T) => void): this;
	onMove(callback: () => void): this;
	onMove<T>(data: T, callback: (data: T) => void): this;
	onCancel(callback: () => void): this;
	onCancel<T>(data: T, callback: (data: T) => void): this;
	getPrice(): number;
	setPrice(value: number): this;
	getText(): string;
	setText(value: string): this;
	getTooltip(): string;
	setTooltip(value: string): this;
	getModifyTooltip(): string;
	setModifyTooltip(value: string): this;
	getCancelTooltip(): string;
	setCancelTooltip(value: string): this;
	getQuantity(): string;
	setQuantity(value: string): this;
	getEditable(): boolean;
	setEditable(value: boolean): this;
	getCancellable(): boolean;
	setCancellable(value: boolean): this;
	getExtendLeft(): boolean;
	setExtendLeft(value: boolean): this;
	getLineLength(): number;
	setLineLength(value: number): this;
	getLineStyle(): number;
	setLineStyle(value: number): this;
	getLineWidth(): number;
	setLineWidth(value: number): this;
	getBodyFont(): string;
	setBodyFont(value: string): this;
	getQuantityFont(): string;
	setQuantityFont(value: string): this;
	getLineColor(): string;
	setLineColor(value: string): this;
	getBodyBorderColor(): string;
	setBodyBorderColor(value: string): this;
	getBodyBackgroundColor(): string;
	setBodyBackgroundColor(value: string): this;
	getBodyTextColor(): string;
	setBodyTextColor(value: string): this;
	getQuantityBorderColor(): string;
	setQuantityBorderColor(value: string): this;
	getQuantityBackgroundColor(): string;
	setQuantityBackgroundColor(value: string): this;
	getQuantityTextColor(): string;
	setQuantityTextColor(value: string): this;
	getCancelButtonBorderColor(): string;
	setCancelButtonBorderColor(value: string): this;
	getCancelButtonBackgroundColor(): string;
	setCancelButtonBackgroundColor(value: string): this;
	getCancelButtonIconColor(): string;
	setCancelButtonIconColor(value: string): this;
}
export interface IPaneApi {
	hasMainSeries(): boolean;
	getLeftPriceScales(): readonly IPriceScaleApi[];
	getRightPriceScales(): readonly IPriceScaleApi[];
	getMainSourcePriceScale(): IPriceScaleApi | null;
	getHeight(): number;
	setHeight(height: number): void;
	moveTo(paneIndex: number): void;
	paneIndex(): number;
}
export interface IPositionLineAdapter {
	remove(): void;
	onClose(callback: () => void): this;
	onClose<T>(data: T, callback: (data: T) => void): this;
	onModify(callback: () => void): this;
	onModify<T>(data: T, callback: (data: T) => void): this;
	onReverse(callback: () => void): this;
	onReverse<T>(data: T, callback: (data: T) => void): this;
	getPrice(): number;
	setPrice(value: number): this;
	getText(): string;
	setText(value: string): this;
	getTooltip(): string;
	setTooltip(value: string): this;
	getProtectTooltip(): string;
	setProtectTooltip(value: string): this;
	getCloseTooltip(): string;
	setCloseTooltip(value: string): this;
	getReverseTooltip(): string;
	setReverseTooltip(value: string): this;
	getQuantity(): string;
	setQuantity(value: string): this;
	getExtendLeft(): boolean;
	setExtendLeft(value: boolean): this;
	getLineLength(): number;
	setLineLength(value: number): this;
	getLineStyle(): number;
	setLineStyle(value: number): this;
	getLineWidth(): number;
	setLineWidth(value: number): this;
	getBodyFont(): string;
	setBodyFont(value: string): this;
	getQuantityFont(): string;
	setQuantityFont(value: string): this;
	getLineColor(): string;
	setLineColor(value: string): this;
	getBodyBorderColor(): string;
	setBodyBorderColor(value: string): this;
	getBodyBackgroundColor(): string;
	setBodyBackgroundColor(value: string): this;
	getBodyTextColor(): string;
	setBodyTextColor(value: string): this;
	getQuantityBorderColor(): string;
	setQuantityBorderColor(value: string): this;
	getQuantityBackgroundColor(): string;
	setQuantityBackgroundColor(value: string): this;
	getQuantityTextColor(): string;
	setQuantityTextColor(value: string): this;
	getReverseButtonBorderColor(): string;
	setReverseButtonBorderColor(value: string): this;
	getReverseButtonBackgroundColor(): string;
	setReverseButtonBackgroundColor(value: string): this;
	getReverseButtonIconColor(): string;
	setReverseButtonIconColor(value: string): this;
	getCloseButtonBorderColor(): string;
	setCloseButtonBorderColor(value: string): this;
	getCloseButtonBackgroundColor(): string;
	setCloseButtonBackgroundColor(value: string): this;
	getCloseButtonIconColor(): string;
	setCloseButtonIconColor(value: string): this;
}
export interface IPriceFormatter extends ISymbolValueFormatter {
	format(price: number, signPositive?: boolean, tailSize?: number, signNegative?: boolean, useRtlFormat?: boolean): string;
}
export interface IPriceScaleApi {
	getMode(): PriceScaleMode;
	setMode(newMode: PriceScaleMode): void;
	isInverted(): boolean;
	setInverted(isInverted: boolean): void;
	/**
	 * Returns `true` when the price scale is locked
	 */
	isLocked(): boolean;
	/**
	 * Set whether the price scale should be locked or not
	 * @param  {boolean} isLocked - set to `true` to lock the price scale
	 */
	setLocked(isLocked: boolean): void;
	/**
	 * Returns `true` when the price scale has auto scaling enabled
	 */
	isAutoScale(): boolean;
	/**
	 * Set whether auto scaling should be enabled or not for the price scale
	 * @param  {boolean} isAutoScale - set to `true` to enable auto scaling
	 */
	setAutoScale(isAutoScale: boolean): void;
	getVisiblePriceRange(): VisiblePriceRange | null;
	setVisiblePriceRange(range: VisiblePriceRange): void;
	hasMainSeries(): boolean;
	getStudies(): EntityId[];
}
export interface ISelectionApi {
	add(entities: EntityId[] | EntityId): void;
	set(entities: EntityId[] | EntityId): void;
	remove(entities: EntityId[]): void;
	contains(entity: EntityId): boolean;
	allSources(): EntityId[];
	isEmpty(): boolean;
	clear(): void;
	onChanged(): ISubscription<() => void>;
	canBeAddedToSelection(entity: EntityId): boolean;
}
export interface ISeparator extends IMenuItem {
	readonly type: MenuItemType.Separator;
}
export interface ISeriesApi {
	isUserEditEnabled(): boolean;
	setUserEditEnabled(enabled: boolean): void;
	mergeUp(): void;
	mergeDown(): void;
	unmergeUp(): void;
	unmergeDown(): void;
	detachToRight(): void;
	detachToLeft(): void;
	detachNoScale(): void;
	changePriceScale(newPriceScale: SeriesPriceScale): void;
	isVisible(): boolean;
	setVisible(visible: boolean): void;
	bringToFront(): void;
	sendToBack(): void;
	entityId(): EntityId;
	chartStyleProperties<T extends ChartStyle>(chartStyle: T): SeriesPreferencesMap[T];
	setChartStyleProperties<T extends ChartStyle>(chartStyle: T, newPrefs: Partial<SeriesPreferencesMap[T]>): void;
}
export interface ISettingsAdapter {
	initialSettings?: InitialSettingsMap;
	setValue(key: string, value: string): void;
	removeValue(key: string): void;
}
/**
 * Shape group API.
 */
export interface IShapesGroupControllerApi {
	/**
	 * Create a group of shapes from the selection.
	 *
	 * @throws If selection is empty, or selection contains non-shapes, or selection contains shapes from more than one pane.
	 * @return The ID of the created group.
	 */
	createGroupFromSelection(): ShapesGroupId;
	/**
	 * Remove a group of shapes.
	 *
	 * @param groupId A group ID.
	 */
	removeGroup(groupId: ShapesGroupId): void;
	/**
	 * Get an array of all shape groups.
	 *
	 * @returns An array of group IDs.
	 */
	groups(): readonly ShapesGroupId[];
	/**
	 * Get an array of IDs for each shape in a group.
	 *
	 * @param groupId A group ID.
	 * @returns An array of shape IDs.
	 */
	shapesInGroup(groupId: ShapesGroupId): readonly EntityId[];
	/**
	 * Remove a shape from a group. If the shape is the only shape in the group then the group is also removed.
	 *
	 * @param groupId A group ID.
	 * @param shapeId A shape ID.
	 */
	excludeShapeFromGroup(groupId: ShapesGroupId, shapeId: EntityId): void;
	/**
	 * Add a shape to a group.
	 *
	 * @param groupId A group ID.
	 * @param shapeId A shape ID.
	 */
	addShapeToGroup(groupId: ShapesGroupId, shapeId: EntityId): void;
	/**
	 * Get an object containing the available Z-order operations for a group.
	 *
	 * @param groupId A group ID.
	 * @returns The available Z-order operations.
	 */
	availableZOrderOperations(groupId: ShapesGroupId): AvailableZOrderOperations;
	/**
	 * Move the group to the top of the Z-order.
	 *
	 * @param groupId A group ID.
	 */
	bringToFront(groupId: ShapesGroupId): void;
	/**
	 * Move the group to the bottom of the Z-order.
	 *
	 * @param groupId A group ID.
	 */
	sendToBack(groupId: ShapesGroupId): void;
	/**
	 * Move the group one level up in the Z-order.
	 *
	 * @param groupId A group ID.
	 */
	bringForward(groupId: ShapesGroupId): void;
	/**
	 * Move the group one level down in the Z-order.
	 *
	 * @param groupId A group ID.
	 */
	sendBackward(groupId: ShapesGroupId): void;
	/**
	 * Move the group immediately below the target in the Z-order.
	 *
	 * @param groupId A group ID.
	 * @param target A target ID.
	 */
	insertAfter(groupId: ShapesGroupId, target: ShapesGroupId | EntityId): void;
	/**
	 * Move the group immediately above the target in the Z-order.
	 *
	 * @param groupId A group ID.
	 * @param target A target ID.
	 */
	insertBefore(groupId: ShapesGroupId, target: ShapesGroupId | EntityId): void;
	/**
	 * Show or hide all shapes in a group.
	 *
	 * @param groupId A group ID.
	 * @param value A boolean flag. `true` to show, `false` to hide.
	 */
	setGroupVisibility(groupId: ShapesGroupId, value: boolean): void;
	/**
	 * Get the visibility state of a group.
	 *
	 * @param groupId A group ID.
	 * @returns The visibility state.
	 */
	groupVisibility(groupId: ShapesGroupId): GroupVisibilityState;
	/**
	 * Lock or unlock a group.
	 *
	 * @param groupId A group ID.
	 * @param value A boolean flag. `true` to lock, `false` to unlock.
	 */
	setGroupLock(groupId: ShapesGroupId, value: boolean): void;
	/**
	 * Get locked state of a group.
	 *
	 * @param groupId A group ID.
	 * @returns The locked state.
	 */
	groupLock(groupId: ShapesGroupId): GroupLockState;
	/**
	 * Get the name of a group.
	 *
	 * @param groupId A group ID.
	 * @returns The name of the group.
	 */
	getGroupName(groupId: ShapesGroupId): string;
	/**
	 * Set the name of a group. Names do not need to be unique.
	 *
	 * @param groupId A group ID.
	 * @param name The new name of the group.
	 */
	setGroupName(groupId: ShapesGroupId, name: string): void;
	/**
	 * Check if some shapes can be grouped.
	 *
	 * @param shapes An array of shape IDs.
	 * @return `true` if the shapes can be groupd, `false` otherwise.
	 */
	canBeGroupped(shapes: readonly EntityId[]): boolean;
}
export interface IStudyApi {
	isUserEditEnabled(): boolean;
	setUserEditEnabled(enabled: boolean): void;
	getInputsInfo(): StudyInputInfo[];
	getInputValues(): StudyInputValueItem[];
	setInputValues(values: StudyInputValueItem[]): void;
	getStyleInfo(): StudyStyleInfo;
	getStyleValues(): StudyStyleValues;
	mergeUp(): void;
	mergeDown(): void;
	unmergeUp(): void;
	unmergeDown(): void;
	changePriceScale(newPriceScale: StudyPriceScale | EntityId): void;
	isVisible(): boolean;
	setVisible(visible: boolean): void;
	bringToFront(): void;
	sendToBack(): void;
	applyOverrides<TOverrides extends StudyOverrides>(overrides: TOverrides): void;
	applyToEntireLayout(): void;
	onDataLoaded(): ISubscription<() => void>;
	onStudyError(): ISubscription<() => void>;
}
export interface ISubscription<TFunc extends Function> {
	subscribe(obj: object | null, member: TFunc, singleshot?: boolean): void;
	unsubscribe(obj: object | null, member: TFunc): void;
	unsubscribeAll(obj: object | null): void;
}
export interface ISymbolValueFormatter {
	format(price: number, signPositive?: boolean): string;
}
export interface ITimeScaleApi {
	coordinateToTime(x: number): number | null;
	/**
	 * This is to detect when the chart has been zoomed in/out
	 */
	barSpacingChanged(): ISubscription<(newBarSpacing: number) => void>;
	/**
	 * This is to detect when the chart has been scrolled left/right
	 */
	rightOffsetChanged(): ISubscription<(rightOffset: number) => void>;
	setRightOffset(offset: number): void;
	setBarSpacing(newBarSpacing: number): void;
	barSpacing(): number;
	rightOffset(): number;
	width(): number;
	defaultRightOffset(): IWatchedValue<number>;
}
export interface ITimezoneApi {
	availableTimezones(): readonly TimezoneInfo[];
	getTimezone(): TimezoneInfo;
	setTimezone(timezone: TimezoneId, options?: UndoOptions): void;
	onTimezoneChanged(): ISubscription<(timezone: TimezoneId) => void>;
}
export interface IUpdatableAction extends IAction {
	update(options: Partial<ActionOptions>): void;
}
export interface IWatchListApi {
	defaultList(): string[];
	getList(id?: string): string[] | null;
	getAllLists(): WatchListSymbolListMap | null;
	setActiveList(id: string): void;
	getActiveListId(): string | null;
	setList(symbols: string[]): void;
	updateList(listId: string, symbols: string[]): void;
	renameList(listId: string, newName: string): void;
	createList(listName?: string, symbols?: string[]): WatchListSymbolList | null;
	saveList(list: WatchListSymbolList): boolean;
	deleteList(listId: string): void;
	onListChanged(): ISubscription<WatchListSymbolListChangedCallback>;
	onActiveListChanged(): ISubscription<EmptyCallback>;
	onListAdded(): ISubscription<WatchListSymbolListAddedCallback>;
	onListRemoved(): ISubscription<WatchListSymbolListRemovedCallback>;
	onListRenamed(): ISubscription<WatchListSymbolListRenamedCallback>;
}
export interface IWatchedValue<T> extends IWatchedValueReadonly<T>, IObservableValue<T> {
	setValue(value: T, forceUpdate?: boolean): void;
	subscribe(callback: WatchedValueCallback<T>, options?: WatchedValueSubscribeOptions): void;
	unsubscribe(callback?: WatchedValueCallback<T> | null): void;
}
export interface IWatchedValueReadonly<T> extends IObservableValueReadOnly<T> {
	subscribe(callback: (value: T) => void, options?: WatchedValueSubscribeOptions): void;
	unsubscribe(callback?: ((value: T) => void) | null): void;
	when(callback: WatchedValueCallback<T>): void;
}
export interface IWidgetbarApi extends IDestroyable {
	showPage(pageName: PageName): void;
	hidePage(pageName: PageName): void;
	isPageVisible(pageName: PageName): boolean;
}
export interface IconOptions {
	icon: number;
}
export interface InitialSettingsMap {
	[key: string]: string;
}
export interface InstrumentInfo {
	qty: QuantityMetainfo;
	pipValue: number;
	pipSize: number;
	minTick: number;
	lotSize?: number;
	type?: SymbolType;
	units?: string;
	brokerSymbol?: string;
	description: string;
	domVolumePrecision?: number;
	leverage?: string;
	marginRate?: number;
	limitPriceStep?: number;
	stopPriceStep?: number;
	allowedDurations?: string[];
	variableMinTick?: string;
	currency?: string;
	baseCurrency?: string;
	quoteCurrency?: string;
	bigPointValue?: number;
	priceMagnifier?: number;
}
export interface IsTradableResult {
	tradable: boolean;
	reason?: string;
	solutions?: TradableSolutions;
	shortReason?: string;
}
export interface KagiStylePreferences {
	upColor: string;
	downColor: string;
	upColorProjection: string;
	downColorProjection: string;
}
export interface LeverageInfo {
	title: string;
	leverage: number;
	min: number;
	max: number;
	step: number;
}
export interface LeverageInfoParams {
	symbol: string;
	orderType: OrderType;
	side: Side;
	customFields?: CustomInputFieldsValues;
}
export interface LeveragePreviewResult {
	infos?: string[];
	warnings?: string[];
	errors?: string[];
}
export interface LeverageSetParams extends LeverageInfoParams {
	leverage: number;
}
export interface LeverageSetResult {
	leverage: number;
}
export interface LibrarySymbolInfo {
	/**
	 * Symbol Name
	 */
	name: string;
	full_name: string;
	base_name?: [
		string
	];
	/**
	 * Unique symbol id
	 */
	ticker?: string;
	description: string;
	type: string;
	/**
	 * @example "1700-0200"
	 */
	session: string;
	session_display?: string;
	/** @deprecated Use session_holidays instead */
	holidays?: string;
	/**
	 * @example "20181105,20181107,20181112"
	 */
	session_holidays?: string;
	/**
	 * @example "1900F4-2350F4,1000-1845:20181113;1000-1400:20181114"
	 */
	corrections?: string;
	/**
	 * Traded exchange
	 * @example "NYSE"
	 */
	exchange: string;
	listed_exchange: string;
	timezone: Timezone;
	/**
	 * Prices format: "price" or "volume"
	 */
	format: SeriesFormat;
	/**
	 * Code (Tick)
	 * @example 8/16/.../256 (1/8/100 1/16/100 ... 1/256/100) or 1/10/.../10000000 (1 0.1 ... 0.0000001)
	 */
	pricescale: number;
	/**
	 * The number of units that make up one tick.
	 * @example For example, U.S. equities are quotes in decimals, and tick in decimals, and can go up +/- .01. So the tick increment is 1. But the e-mini S&P futures contract, though quoted in decimals, goes up in .25 increments, so the tick increment is 25. (see also Tick Size)
	 */
	minmov: number;
	fractional?: boolean;
	/**
	 * @example Quarters of 1/32: pricescale=128, minmovement=1, minmovement2=4
	 */
	minmove2?: number;
	/**
	 * false if DWM only
	 */
	has_intraday?: boolean;
	/**
	 * An array of resolutions which should be enabled in resolutions picker for this symbol.
	 */
	supported_resolutions: ResolutionString[];
	/**
	 * @example (for ex.: "1,5,60") - only these resolutions will be requested, all others will be built using them if possible
	 */
	intraday_multipliers?: string[];
	has_seconds?: boolean;
	has_ticks?: boolean;
	/**
	 * It is an array containing seconds resolutions (in seconds without a postfix) the datafeed builds by itself.
	 */
	seconds_multipliers?: string[];
	has_daily?: boolean;
	has_weekly_and_monthly?: boolean;
	has_empty_bars?: boolean;
	/**
	 * @deprecated
	 * use visible_plots_set instead
	 */
	has_no_volume?: boolean;
	/**
	 * Represents what values are supported by the symbol
	 */
	visible_plots_set?: VisiblePlotsSet;
	/**
	 * Integer showing typical volume value decimal places for this symbol
	 */
	volume_precision?: number;
	data_status?: "streaming" | "endofday" | "pulsed" | "delayed_streaming";
	/**
	 * Boolean showing whether this symbol is expired futures contract or not.
	 */
	expired?: boolean;
	/**
	 * Unix timestamp of expiration date.
	 */
	expiration_date?: number;
	sector?: string;
	industry?: string;
	currency_code?: string;
	original_currency_code?: string;
	unit_id?: string;
	original_unit_id?: string;
	unit_conversion_types?: string[];
}
export interface LineBreakStylePreferences {
	upColor: string;
	downColor: string;
	borderUpColor: string;
	borderDownColor: string;
	upColorProjection: string;
	downColorProjection: string;
	borderUpColorProjection: string;
	borderDownColorProjection: string;
}
export interface LineStylePreferences {
	color: string;
	linestyle: number;
	linewidth: number;
	styleType: number;
}
export interface LoadingScreenOptions {
	foregroundColor?: string;
	backgroundColor?: string;
}
export interface MappedObject<TValue> {
	[key: string]: TValue | undefined;
}
export interface Mark {
	id: string | number;
	time: number;
	color: MarkConstColors | MarkCustomColor;
	text: string;
	label: string;
	labelFontColor: string;
	minSize: number;
}
export interface MarkCustomColor {
	color: string;
	background: string;
}
export interface MenuSeparator extends ActionDescription {
	separator: boolean;
}
export interface MouseEventParams {
	clientX: number;
	clientY: number;
	pageX: number;
	pageY: number;
	screenX: number;
	screenY: number;
}
export interface NegativeBaseInputFieldValidatorResult extends BaseInputFieldValidatorResult {
	valid: false;
	errorMessage: string;
}
export interface NewsItem {
	title: string;
	source: string;
	published: number;
	link?: string;
	shortDescription?: string;
	fullDescription?: string;
}
export interface NumericFormattingParams {
	decimal_sign: string;
}
export interface OrderDialogOptions extends TradingDialogOptions {
}
export interface OrderDuration {
	/**
	 * type is OrderDurationMetaInfo.value
	 */
	type: string;
	datetime?: number;
}
export interface OrderDurationMetaInfo {
	hasDatePicker?: boolean;
	hasTimePicker?: boolean;
	default?: boolean;
	name: string;
	value: string;
	supportedOrderTypes?: OrderType[];
}
export interface OrderOrPositionMessage {
	type: OrderOrPositionMessageType;
	text: string;
}
export interface OrderPreviewResult {
	sections: OrderPreviewSection[];
	confirmId?: string;
	warnings?: string[];
	errors?: string[];
}
export interface OrderPreviewSection {
	rows: OrderPreviewSectionRow[];
	header?: string;
}
export interface OrderPreviewSectionRow {
	title: string;
	value: string;
}
export interface OrderRule {
	id: string;
	severity: "warning" | "error";
}
export interface OrderTableColumn extends AccountManagerColumn {
	supportedStatusFilters?: OrderStatusFilter[];
}
/**
 * Input value of the order ticket
 * This info is not sufficient to place an order
 */
export interface OrderTemplate {
	symbol: string;
	type?: OrderType;
	side?: Side;
	qty?: number;
	stopPrice?: number;
	limitPrice?: number;
	takeProfit?: number;
	stopLoss?: number;
	trailingStopPips?: number;
	duration?: OrderDuration;
	customFields?: CustomInputFieldsValues;
}
export interface Overrides {
	[key: string]: string | number | boolean;
}
export interface PeriodParams {
	from: number;
	to: number;
	countBack: number;
	firstDataRequest: boolean;
}
export interface PipValues {
	buyPipValue: number;
	sellPipValue: number;
}
export interface PlaceOrderResult {
	orderId?: string;
}
/**
 * Info about a placed order
 */
export interface PlacedOrder extends CustomFields {
	id: string;
	symbol: string;
	type: OrderType;
	side: Side;
	qty: number;
	status: OrderStatus;
	stopLoss?: number;
	trailingStopPips?: number;
	stopType?: StopType;
	takeProfit?: number;
	duration?: OrderDuration;
	customFields?: CustomInputFieldsValues;
	filledQty?: number;
	avgPrice?: number;
	updateTime?: number; /** unix timestamp in milliseconds */
	limitPrice?: number;
	stopPrice?: number;
	message?: OrderOrPositionMessage;
}
export interface PlusClickParams extends MouseEventParams {
	symbol: string | null;
	price: number;
}
export interface PnFStylePreferences {
	upColor: string;
	downColor: string;
	upColorProjection: string;
	downColorProjection: string;
}
export interface PolygonPreferences {
	transparency: number;
	color: string;
}
export interface Position {
	id: string;
	symbol: string;
	qty: number;
	shortQty?: number;
	longQty?: number;
	side: Side;
	avgPrice: number;
	message?: OrderOrPositionMessage;
	[key: string]: any;
}
export interface PositionDialogOptions extends TradingDialogOptions {
}
export interface PositiveBaseInputFieldValidatorResult extends BaseInputFieldValidatorResult {
	valid: true;
}
/**
 * Output value of the order ticket and input value of the broker's place order command
 * This info is sufficient to place an order
 */
export interface PreOrder extends OrderTemplate {
	symbol: string;
	type: OrderType;
	side: Side;
	qty: number;
	seenPrice: number | null;
	isClose?: boolean;
}
export interface PricedPoint extends TimePoint {
	price: number;
}
export interface QuantityMetainfo {
	min: number;
	max: number;
	step: number;
	uiStep?: number;
	default?: number;
}
export interface QuoteErrorData {
	s: "error";
	n: string;
	v: object;
}
export interface QuoteOkData {
	s: "ok";
	n: string;
	v: DatafeedQuoteValues;
}
export interface RenkoStylePreferences {
	upColor: string;
	downColor: string;
	borderUpColor: string;
	borderDownColor: string;
	upColorProjection: string;
	downColorProjection: string;
	borderUpColorProjection: string;
	borderDownColorProjection: string;
	wickUpColor: string;
	wickDownColor: string;
}
export interface RestBrokerConnectionInfo {
	url: string;
	access_token: string;
}
export interface RssNewsFeedInfo {
	url: string;
	name: string;
}
export interface RssNewsFeedParams {
	default: RssNewsFeedItem;
	[symbolType: string]: RssNewsFeedItem;
}
export interface SaveChartToServerOptions {
	chartName?: string;
	defaultChartName?: string;
}
export interface SaveLoadChartRecord {
	id: string;
	name: string;
	image_url: string;
	modified_iso: number;
	short_symbol: string;
	interval: ResolutionString;
}
export interface SavedStateMetaInfo {
	uid: number;
	name: string;
	description: string;
}
export interface SearchSymbolResultItem {
	symbol: string;
	full_name: string;
	description: string;
	exchange: string;
	ticker: string;
	type: string;
}
export interface SeriesFieldDescriptor {
	type: "value";
	sourceType: "series";
	plotTitle: string;
	sourceTitle: string;
}
export interface SeriesPreferencesMap {
	[ChartStyle.Bar]: BarStylePreferences;
	[ChartStyle.Candle]: CandleStylePreferences;
	[ChartStyle.Line]: LineStylePreferences;
	[ChartStyle.Area]: AreaStylePreferences;
	[ChartStyle.Renko]: RenkoStylePreferences;
	[ChartStyle.Kagi]: KagiStylePreferences;
	[ChartStyle.PnF]: PnFStylePreferences;
	[ChartStyle.LineBreak]: LineBreakStylePreferences;
	[ChartStyle.HeikinAshi]: HeikinAshiStylePreferences;
	[ChartStyle.HollowCandle]: HollowCandleStylePreferences;
	[ChartStyle.Baseline]: BaselineStylePreferences;
	[ChartStyle.HiLo]: HiLoStylePreferences;
	[ChartStyle.Column]: ColumnStylePreferences;
}
/**
 * Options for setting the visible range.
 *
 * Setting `applyDefaultRightMargin` or `percentRightMargin` will result in the `to` value
 * of the range specified being ignored and the timestamp of the latest bar on the chart
 * being used instead.
 */
export interface SetVisibleRangeOptions {
	/**
	 * Apply the default right offset (margin) when setting the range.
	 */
	applyDefaultRightMargin?: boolean;
	/**
	 * Apply a percentage right offset (margin) when setting the range.
	 */
	percentRightMargin?: number;
}
export interface SingleBrokerMetaInfo {
	configFlags: BrokerConfigFlags;
	customNotificationFields?: string[];
	durations?: OrderDurationMetaInfo[];
	positionDialogOptions?: PositionDialogOptions;
	orderRules?: OrderRule[];
	customUI?: BrokerCustomUI;
}
export interface SortingParameters {
	columnId: string;
	asc?: boolean;
}
export interface StickedPoint extends TimePoint {
	channel: "open" | "high" | "low" | "close";
}
export interface StudyAlertConditionPlotInfo extends StudyPlotBaseInfo {
	readonly type: StudyPlotType.AlertCondition;
}
export interface StudyArrowsPlotInfo extends StudyPlotBaseInfo {
	readonly type: StudyPlotType.Arrows;
}
export interface StudyArrowsPlotPreferences {
	visible: boolean;
	transparency: number;
	colorup: string;
	colordown: string;
}
export interface StudyBandInfo {
	readonly id?: string;
	readonly name: string;
	readonly isHidden?: boolean;
	readonly zorder?: number;
}
export interface StudyBandStyle extends MappedObject<string | number | boolean> {
	color: string;
	linestyle: number;
	linewidth: number;
	value: number;
	visible: boolean;
}
export interface StudyBarColorerPlotInfo extends StudyPalettedPlotInfo {
	readonly type: StudyPlotType.BarColorer;
}
export interface StudyBgColorerPlotInfo extends StudyPalettedPlotInfo {
	readonly type: StudyPlotType.BgColorer;
}
export interface StudyCandleBorderColorerPlotInfo extends StudyPalettedPlotInfo, StudyTargetedPlotInfo {
	readonly type: StudyPlotType.CandleBorderColorer;
}
export interface StudyCandleWickColorerPlotInfo extends StudyPalettedPlotInfo, StudyTargetedPlotInfo {
	readonly type: StudyPlotType.CandleWickColorer;
}
export interface StudyCharsPlotInfo extends StudyPlotBaseInfo {
	readonly type: StudyPlotType.Chars;
}
export interface StudyCharsPlotPreferences {
	visible: boolean;
	transparency: number;
	char: string;
	location: MarkLocation;
	color: string;
	textColor: string;
}
export interface StudyColorerPlotInfo extends StudyPalettedPlotInfo, StudyTargetedPlotInfo {
	readonly type: StudyPlotType.Colorer;
}
export interface StudyDataOffsetPlotInfo extends StudyTargetedPlotInfo {
	readonly type: StudyPlotType.DataOffset;
}
export interface StudyDownColorerPlotInfo extends StudyPalettedPlotInfo, StudyTargetedPlotInfo {
	readonly type: StudyPlotType.DownColorer;
}
export interface StudyFieldDescriptor {
	type: "value";
	sourceType: "study";
	sourceId: string;
	sourceTitle: string;
	plotTitle: string;
}
export interface StudyFilledAreaInfo extends MappedObject<string | number | boolean> {
	readonly id: string;
	readonly objAId: string;
	readonly objBId: string;
	readonly title: string;
	readonly type: FilledAreaType;
	readonly fillgaps?: boolean;
	readonly zorder?: number;
}
export interface StudyFilledAreaStyle extends MappedObject<string | number | boolean> {
	color: string;
	transparency: number;
	visible: boolean;
}
export interface StudyInputInfo {
	id: StudyInputId;
	name: string;
	type: string;
	localizedName: string;
}
export interface StudyInputValueItem {
	id: StudyInputId;
	value: StudyInputValue;
}
export interface StudyLinePlotInfo extends StudyPlotBaseInfo {
	readonly type: StudyPlotType.Line;
}
export interface StudyLinePlotPreferences {
	visible: boolean;
	transparency: number;
	plottype: LineStudyPlotStyle;
	color: string;
	linestyle: LineStyle;
	linewidth: number;
	trackPrice: boolean;
}
export interface StudyOhlcColorerPlotInfo extends StudyPalettedPlotInfo, StudyTargetedPlotInfo {
	readonly type: StudyPlotType.OhlcColorer;
}
export interface StudyOhlcPlotBarsStylePreferences {
	plottype: OhlcStudyPlotStyle.OhlcBars;
	visible: boolean;
	color: string;
}
export interface StudyOhlcPlotCandlesStylePreferences {
	plottype: OhlcStudyPlotStyle.OhlcCandles;
	visible: boolean;
	drawWick: boolean;
	drawBorder: boolean;
	color: string;
	wickColor: string;
	borderColor: string;
}
export interface StudyOhlcPlotInfo extends StudyTargetedPlotInfo {
	readonly type: StudyPlotType.OhlcOpen | StudyPlotType.OhlcHigh | StudyPlotType.OhlcLow | StudyPlotType.OhlcClose;
}
export interface StudyOrDrawingAddedToChartEventParams {
	value: string;
}
export interface StudyOverrides {
	[key: string]: StudyOverrideValueType;
}
export interface StudyPaletteColor {
	color: string;
	style: number;
	width: number;
}
export interface StudyPaletteInfo {
	readonly name: string;
}
export interface StudyPaletteStyle {
	colors: MappedObject<StudyPaletteColor>;
}
export interface StudyPalettedPlotInfo extends StudyPlotBaseInfo {
	readonly palette: string;
}
export interface StudyPalettesInfo {
	readonly colors: MappedObject<StudyPaletteInfo>;
	readonly valToIndex?: MappedObject<number>;
	readonly addDefaultColor?: boolean;
}
export interface StudyPlotBaseInfo {
	readonly id: string;
	readonly type: string;
}
export interface StudyShapesPlotInfo extends StudyPlotBaseInfo {
	readonly type: StudyPlotType.Shapes;
}
export interface StudyShapesPlotPreferences {
	visible: boolean;
	transparency: number;
	plottype: PlotShapeId;
	location: MarkLocation;
	color: string;
	textColor: string;
}
export interface StudyStyleInfo {
	defaults?: StudyStyleInfoDefaults;
	plots?: readonly Readonly<StudyPlotInfo>[];
	styles?: StudyStylesInfo;
	bands?: readonly Readonly<StudyBandInfo>[];
	filledAreas?: readonly Readonly<StudyFilledAreaInfo>[];
	palettes?: Record<string, Readonly<StudyPalettesInfo> | undefined>;
}
export interface StudyStyleInfoDefaults {
	bands?: readonly StudyBandStyle[];
	filledAreasStyle?: Record<string, StudyFilledAreaStyle | undefined>;
	palettes?: Record<string, StudyPaletteStyle | undefined>;
	styles?: Record<string, StudyPlotPreferences | undefined>;
	ohlcPlots?: Record<string, StudyOhlcPlotPreferences | undefined>;
	graphics?: {
		horizlines?: Record<string, HorizLinePreferences | undefined>;
		polygons?: Record<string, PolygonPreferences | undefined>;
		hhists?: Record<string, HHistPreferences | undefined>;
		vertlines?: Record<string, VertLinePreferences | undefined>;
	};
}
export interface StudyStylesInfo {
	readonly histogramBase?: number;
	readonly joinPoints?: boolean;
	readonly title?: string;
	readonly isHidden?: boolean;
	readonly minHeight?: number;
	readonly maxHeight?: number;
	readonly size?: PlotSymbolSize;
	readonly text?: string;
	readonly showLast?: number;
	readonly zorder?: number;
}
export interface StudyTargetedPlotInfo extends StudyPlotBaseInfo {
	readonly target: string;
}
export interface StudyTemplateData {
	name: string;
	content: string;
}
export interface StudyTemplateMetaInfo {
	name: string;
}
export interface StudyTextColorerPlotInfo extends StudyPalettedPlotInfo, StudyTargetedPlotInfo {
	readonly type: StudyPlotType.TextColorer;
}
export interface StudyUpColorerPlotInfo extends StudyPalettedPlotInfo, StudyTargetedPlotInfo {
	readonly type: StudyPlotType.UpColorer;
}
export interface SubscribeEventsMap {
	toggle_sidebar: (isHidden: boolean) => void;
	indicators_dialog: EmptyCallback;
	toggle_header: (isHidden: boolean) => void;
	edit_object_dialog: (params: EditObjectDialogEventParams) => void;
	chart_load_requested: (savedData: object) => void;
	chart_loaded: EmptyCallback;
	mouse_down: (params: MouseEventParams) => void;
	mouse_up: (params: MouseEventParams) => void;
	drawing: (params: StudyOrDrawingAddedToChartEventParams) => void;
	study: (params: StudyOrDrawingAddedToChartEventParams) => void;
	undo: EmptyCallback;
	redo: EmptyCallback;
	undo_redo_state_changed: (state: UndoRedoState) => void;
	reset_scales: EmptyCallback;
	compare_add: EmptyCallback;
	add_compare: EmptyCallback;
	"load_study template": EmptyCallback;
	onTick: (tick: Bar) => void;
	onAutoSaveNeeded: EmptyCallback;
	onScreenshotReady: (url: string) => void;
	onMarkClick: (markId: Mark["id"]) => void;
	onPlusClick: (params: PlusClickParams) => void;
	onTimescaleMarkClick: (markId: TimescaleMark["id"]) => void;
	onSelectedLineToolChanged: EmptyCallback;
	layout_about_to_be_changed: (newLayoutType: LayoutType) => void;
	layout_changed: EmptyCallback;
	activeChartChanged: (chartIndex: number) => void;
	series_event: (seriesEventType: SeriesEventType) => void;
	study_event: (entityId: EntityId, studyEventType: StudyEventType) => void;
	drawing_event: (sourceId: EntityId, drawingEventType: DrawingEventType) => void;
	study_properties_changed: (id: EntityId) => void;
	series_properties_changed: (id: EntityId) => void;
	panes_height_changed: () => void;
	panes_order_changed: () => void;
}
export interface SuccessFormatterParseResult<T> extends FormatterParseResult {
	res: true;
	value: T;
	suggest?: string;
}
/**
 * Extended symbol information.
 */
export interface SymbolExt {
	/**
	 * Symbol name. E.g. `'AAPL'`.
	 */
	symbol: string;
	/**
	 * Full symbol name. E.g. `'NasdaqNM:AAPL'`.
	 */
	full_name: string;
	/**
	 * Exchange name. E.g. `'NasdaqNM`'
	 */
	exchange: string;
	/**
	 * Symbol description. E.g. `'Apple Inc.'`.
	 */
	description: string;
	/**
	 * Symbol type. E.g. `'stock'`.
	 */
	type: string;
}
export interface SymbolIntervalResult {
	symbol: string;
	interval: ResolutionString;
}
export interface SymbolResolveExtension {
	currencyCode?: string;
	unitId?: string;
}
export interface TextWithCheckboxFieldCustomInfo {
	checkboxTitle: string;
	asterix?: boolean;
}
export interface TextWithCheckboxFieldMetaInfo extends CustomInputFieldMetaInfo {
	inputType: "TextWithCheckBox";
	value: TextWithCheckboxValue;
	customInfo: TextWithCheckboxFieldCustomInfo;
	validator?: TextInputFieldValidator;
}
export interface TextWithCheckboxValue {
	text: string;
	checked: boolean;
}
export interface TimeFieldDescriptor {
	type: "time";
}
export interface TimeFrameItem {
	text: string;
	resolution: ResolutionString;
	description?: string;
	title?: string;
}
export interface TimeFramePeriodBack {
	type: TimeFrameType.PeriodBack;
	value: string;
}
export interface TimeFrameTimeRange {
	type: TimeFrameType.TimeRange;
	from: number;
	to: number;
}
export interface TimePoint {
	time: number;
}
export interface TimeScaleOptions {
	min_bar_spacing?: number;
}
export interface TimescaleMark {
	id: string | number;
	time: number;
	color: MarkConstColors | string;
	label: string;
	tooltip: string[];
}
export interface TimezoneInfo {
	id: TimezoneId;
	title: string;
	offset?: number;
}
export interface Trade extends CustomFields {
	id: string;
	date: number;
	symbol: string;
	qty: number;
	side: Side;
	price: number;
}
export interface TradeContext {
	symbol: string;
	displaySymbol: string;
	value: number | null;
	formattedValue: string;
	last: number;
}
export interface TradingCustomization {
	position: Overrides;
	order: Overrides;
}
export interface TradingDialogOptions {
	customFields?: TradingDialogCustomField[];
}
export interface TradingQuotes {
	trade?: number;
	size?: number;
	bid?: number;
	bid_size?: number;
	ask?: number;
	ask_size?: number;
	spread?: number;
	isDelayed?: boolean;
	isHalted?: boolean;
	isHardToBorrow?: boolean;
	isNotShortable?: boolean;
}
export interface TradingTerminalWidgetOptions extends ChartingLibraryWidgetOptions {
	brokerConfig?: SingleBrokerMetaInfo;
	broker_config?: SingleBrokerMetaInfo;
	restConfig?: RestBrokerConnectionInfo;
	widgetbar?: WidgetBarParams;
	rss_news_feed?: RssNewsFeedParams;
	news_provider?: GetNewsFunction;
	trading_customization?: TradingCustomization;
	brokerFactory?(host: IBrokerConnectionAdapterHost): IBrokerWithoutRealtime | IBrokerTerminal;
	broker_factory?(host: IBrokerConnectionAdapterHost): IBrokerWithoutRealtime | IBrokerTerminal;
}
export interface TranslateOptions {
	plural?: string;
	count?: number;
	context?: string;
	replace?: Record<string, string>;
}
/**
 * Undo options.
 */
export interface UndoOptions {
	/**
	 * A boolean flag. Controls if undo should be disabled.
	 */
	disableUndo?: boolean;
}
export interface UndoRedoState {
	readonly enableUndo: boolean;
	readonly undoText: string | undefined;
	readonly enableRedo: boolean;
	readonly redoText: string | undefined;
}
export interface Unit {
	id: string;
	name: string;
	description: string;
}
export interface UserTimeFieldDescriptor {
	type: "userTime";
}
export interface VertLinePreferences {
	visible: boolean;
	width: number;
	color: string;
	style: LineStyle;
}
export interface VisiblePriceRange {
	from: number;
	to: number;
}
/**
 * A time range.
 */
export interface VisibleTimeRange {
	/**
	 * A UNIX timestamp. The start of the range.
	 */
	from: number;
	/**
	 * A UNIX timestamp. The end of the range.
	 */
	to: number;
}
export interface WatchListSymbolList extends WatchListSymbolListData {
	id: string;
}
export interface WatchListSymbolListData {
	symbols: string[];
	title: string;
}
export interface WatchListSymbolListMap {
	[listId: string]: WatchListSymbolList;
}
export interface WatchedValueSubscribeOptions {
	once?: boolean;
	callWithLast?: boolean;
}
export interface WidgetBarParams {
	details?: boolean;
	watchlist?: boolean;
	news?: boolean;
	datawindow?: boolean;
	watchlist_settings?: {
		default_symbols: string[];
		readonly?: boolean;
	};
}
export type CustomTimezones = "Africa/Cairo" | "Africa/Johannesburg" | "Africa/Lagos" | "America/Argentina/Buenos_Aires" | "America/Bogota" | "America/Caracas" | "America/Chicago" | "America/El_Salvador" | "America/Juneau" | "America/Lima" | "America/Los_Angeles" | "America/Mexico_City" | "America/New_York" | "America/Phoenix" | "America/Santiago" | "America/Sao_Paulo" | "America/Toronto" | "America/Vancouver" | "Asia/Almaty" | "Asia/Ashkhabad" | "Asia/Bahrain" | "Asia/Bangkok" | "Asia/Chongqing" | "Asia/Dubai" | "Asia/Ho_Chi_Minh" | "Asia/Hong_Kong" | "Asia/Jakarta" | "Asia/Jerusalem" | "Asia/Karachi" | "Asia/Kathmandu" | "Asia/Kolkata" | "Asia/Kuwait" | "Asia/Manila" | "Asia/Muscat" | "Asia/Qatar" | "Asia/Riyadh" | "Asia/Seoul" | "Asia/Shanghai" | "Asia/Singapore" | "Asia/Taipei" | "Asia/Tehran" | "Asia/Tokyo" | "Atlantic/Reykjavik" | "Australia/ACT" | "Australia/Adelaide" | "Australia/Brisbane" | "Australia/Perth" | "Australia/Sydney" | "Europe/Amsterdam" | "Europe/Athens" | "Europe/Belgrade" | "Europe/Berlin" | "Europe/Bratislava" | "Europe/Brussels" | "Europe/Bucharest" | "Europe/Budapest" | "Europe/Copenhagen" | "Europe/Dublin" | "Europe/Helsinki" | "Europe/Istanbul" | "Europe/Lisbon" | "Europe/London" | "Europe/Luxembourg" | "Europe/Madrid" | "Europe/Malta" | "Europe/Moscow" | "Europe/Oslo" | "Europe/Paris" | "Europe/Riga" | "Europe/Rome" | "Europe/Stockholm" | "Europe/Tallinn" | "Europe/Vilnius" | "Europe/Warsaw" | "Europe/Zurich" | "Pacific/Auckland" | "Pacific/Chatham" | "Pacific/Fakaofo" | "Pacific/Honolulu" | "Pacific/Norfolk" | "US/Mountain";

export as namespace TradingView;

export {};
